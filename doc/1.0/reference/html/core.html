<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;2.&nbsp;Components, Widgets and Services</title><link rel="stylesheet" href="../css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="Aranea&#8212;Java Web Framework Construction and Integration Kit"><link rel="up" href="index.html" title="Aranea&#8212;Java Web Framework Construction and Integration Kit"><link rel="prev" href="intro.html" title="Chapter&nbsp;1.&nbsp;Introduction"><link rel="next" href="framework.html" title="Chapter&nbsp;3.&nbsp;Framework and Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;2.&nbsp;Components, Widgets and Services</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="framework.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="core"></a>Chapter&nbsp;2.&nbsp;Components, Widgets and Services</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e209"></a>2.1.&nbsp;Introduction</h2></div></div></div><p>Aranea framework and component model are very simple and implemented
    purely in Plain Old Java. There are no XML mappings, code generation or
    bytecode enhancement. The whole component model consists mainly of five
    interfaces: <code class="classname">org.araneaframework.Component</code>,
    <code class="classname">org.araneaframework.Service</code>,
    <code class="classname">org.araneaframework.Widget</code>,
    <code class="classname">org.araneaframework.Environment</code>,
    <code class="classname">org.araneaframework.Message</code> and some conventions
    regarding their usage and implementation.</p><p>This chapter describes the core Aranea abstractions in detail
    generally not necessary to just develop application code so it can be
    skipped during the first reading. It is quite dry on the examples, but its
    understanding is crucial to develop Aranea extensions. To get a quick
    understanding of how to program applications with widgets read <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e233"></a>2.2.&nbsp;Coding Conventions</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e236"></a>2.2.1.&nbsp;Checked versus Unchecked Exceptions</h3></div></div></div><p>It is our firm belief that checked exceptions are unnecessary in
      <span class="emphasis"><em>Controller</em></span> and therefore Aranea will in most cases
      allow to just declare your overriding method as <code class="literal">throws
      Exception</code>. On the other hand no framework interfaces throw
      checked exceptions so the exception-handling boilerplate can be
      delegated to a single error-handling component.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e247"></a>2.2.2.&nbsp;Public versus Framework Interfaces</h3></div></div></div><p>Since the application programmer implements the same components
      that are used for framework extension, it is important to discourage the
      access to public framework interfaces (which are necessarily visible in
      the overridden classes). Thus a simple convention is applied for core
      framework interfaces, which is best illustrated with the following
      example.</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Service <span class="syntax6">extends</span> Component, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getService</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(Path path, InputData input, OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>As one can see, the real interface methods are relocated to an
      inner interface named <code class="classname">Interface</code>, that can be
      accessed using a method
      <code class="classname">_get&lt;InterfaceName&gt;()</code>, which starts with an
      underscore to discourage its use. As a rule of a thumb, in Aranea the
      methods starting with an underscore should only be used, when one really
      knows what one is doing.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e262"></a>2.2.3.&nbsp;Components and Their Orthogonal Properties</h3></div></div></div><p>Aranea has three main types of components:
      <code class="classname">org.araneaframework.Component</code>,
      <code class="classname">org.araneaframework.Service</code> and
      <code class="classname">org.araneaframework.Widget</code>. These components also
      have a number of orthogonal properties (like
      <code class="classname">Viewable</code>, <code class="classname">Composite</code>),
      which are represented by interfaces that need to be implemented. Since
      some particular API methods expect a particular type of component with a
      particular property (e.g. <code class="classname">ViewableWidget</code>) one
      would either have to abandon static type safety or define a lot of
      meaningless interfaces that would clutter the Javadoc index and confuse
      the source code readers. The approach chosen in Aranea is to make such
      interfaces internal to the property, like in the following
      example.</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Viewable <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getViewable</span>();

  <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Object <span class="syntax9">getViewModel</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableComponent <span class="syntax6">extends</span> Viewable, Component, Serializable <span class="syntax11">{}</span>
  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableService <span class="syntax6">extends</span> ViewableComponent, Service, Serializable <span class="syntax11">{}</span>
  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableWidget <span class="syntax6">extends</span> ViewableService, Widget, Serializable <span class="syntax11">{}</span>
<span class="syntax11">}</span>
</span></pre></pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-components-environment"></a>2.3.&nbsp;Components and Environment</h2></div></div></div><p><code class="classname">org.araneaframework.Component</code> represents the
    unit of encapsulation and reuse in Aranea. Components are used to both
    provide plug-ins and extensions to the framework and to implement the
    actual application-specific code. A component has (possibly persistent)
    state, life cycle, environment and a messaging mechanism. </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Component <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Component.Interface <span class="syntax9">_getComponent</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">init</span>(Environment env) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">destroy</span>() <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">propagate</span>(Message message) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">enable</span>() <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">disable</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>The component life cycle goes as follows: </p><div class="orderedlist"><ol type="1" compact><li><code class="function">init()</code>

           &#8212;notifies the component that it should initialize itself passing it the 

          <code class="classname">Environment</code>

           . A component can be initialized only once and the environment it is given stays with it until it is destroyed. 
        </li><li>
           All other calls (like 

          <code class="literal">propagate()</code>

           ) should be done when a component is alive, initialized and enabled. 
        </li><li><code class="function">disable()</code>

           &#8212;notifies the component that it will be disabled and will not receive any calls until it is enabled again. A component is enabled by default. 
        </li><li><code class="function">enable()</code>

           &#8212;notifies the component that it has been enabled again. This call may only be done after a 

          <code class="classname">disable()</code>

           call. 
        </li><li><code class="function">destroy()</code>

           &#8212;notifies the component that it has been destroyed and should release any acquired resources and such. A component can be destroyed only once and should be initialized before that. 
        </li></ol></div><p> Further in the text we will refer to an initialized and
    not destroyed component instance that has a parent as
    <span class="emphasis"><em>live</em></span> and one that has not been disabled or has been
    re-enabled as <span class="emphasis"><em>enabled</em></span>.</p><p>Aranea provides a base implementation of the
    <code class="literal">Component</code> &#8212;
    <code class="literal">org.araneaframework.core.BaseComponent</code>. This
    implementation mainly enforces contracts (including life cycle and some
    basic synchronization). A base class for application development
    <code class="literal">org.araneaframework.core.BaseApplicationComponent</code> is
    also available.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e344"></a>2.3.1.&nbsp;Composite Pattern and Paths</h3></div></div></div><p><span class="emphasis"><em>Composite</em></span> pattern refers to a design approach
      prominent (specifically) in the GUI modeling when objects implementing
      the same interface are arranged in a hierarchy by containment, where the
      nodes of the tree propagate calls in some way to the leafs of the tree.
      It is shown on <a href="core.html#composite-pattern" title="Figure&nbsp;2.1.&nbsp;Composite design pattern">Figure&nbsp;2.1, &#8220;<span class="emphasis"><em>Composite</em></span> design pattern&#8221;</a>.</p><div class="figure"><a name="composite-pattern"></a><div class="mediaobject"><img src="../images/composite.png" alt="Composite design pattern"></div><p class="title"><b>Figure&nbsp;2.1.&nbsp;<span class="emphasis"><em>Composite</em></span> design pattern</b></p></div><p><span class="emphasis"><em>Composite</em></span> is one of the main patterns used in
      Aranea. It is mainly used to create a <span class="emphasis"><em>Hierarchical
      Controller</em></span> using <code class="literal">Component</code> containment. In
      terms of <code class="literal">Component</code> interface
      <span class="emphasis"><em>Composite</em></span> is used to propagate life cycle events
      and route messages (see <a href="core.html#components-messaging" title="2.3.3.&nbsp;Messaging Components">Section&nbsp;2.3.3, &#8220;Messaging Components&#8221;</a>).</p><p>The flavor of the <span class="emphasis"><em>Composite</em></span> pattern as used
      in Aranea typically means that every contained component has some kind
      of an identifier or name that distinguishes it from other children of
      the same parent (note that the child is not typically aware of its
      identifier). This identifiers are used to route messages and events and
      can be combined to form a full identifier which describes a "path" from
      the root component to the child in question. This paths are represented
      by a <span class="emphasis"><em>Iterator</em></span>-like interface
      <code class="literal">org.araneaframework.Path</code>. </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Path <span class="syntax6">extends</span> Cloneable, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Object <span class="syntax9">getNext</span>();
  <span class="syntax6">public</span> Object <span class="syntax9">next</span>();
  <span class="syntax6">public</span> <span class="syntax8">boolean</span> <span class="syntax9">hasNext</span>();
<span class="syntax11">}</span>
</span></pre></pre><p>Each <code class="literal">next()</code> call will return the identifier of
      the next child in the path to the descendant in question. Default
      implementation
      (<code class="literal">org.araneaframework.core.StandardPath</code>) uses simple
      string identifiers like "a" or "b" and combines them using dots forming
      full paths like "a.b.c".</p><p>A <span class="emphasis"><em>Composite</em></span> component may want to make its
      children visible to the outside world by implementing the
      <code class="literal">org.araneaframework.Composite</code> interface:
      </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Composite <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Composite.Interface <span class="syntax9">_getComposite</span>();
  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Map <span class="syntax9">getChildren</span>();
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">attach</span>(Object key, Component comp);
    <span class="syntax6">public</span> Component <span class="syntax9">detach</span>(Object key); 
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>This interface allows to both inspect and manipulate component
      children by attaching and detaching them from the parent
      component.</p><p>As most of the Aranea abstractions are built to be used with the
      <span class="emphasis"><em>Composite</em></span> concept we will illustrate it in greater
      detail when examining other abstractions and their implementation.
      Further on we will assume that any <code class="literal">Component</code> has a
      parent that contains it and every child has some kind of name in
      relation to the parent unless noted otherwise (obviously there is at
      least one <span class="emphasis"><em>Composite</em></span> that does not have a parent,
      but we don't really care about that at the moment).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="core-environment"></a>2.3.2.&nbsp;Environment</h3></div></div></div><p><code class="literal">org.araneaframework.Environment</code> is another
      important concept that represents the way <code class="literal">Component</code>s
      interact with the framework. <code class="literal">Environment</code> interface is
      rather simple: </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Environment <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Object <span class="syntax9">getEntry</span>(Object key);
<span class="syntax11">}</span>
</span></pre></pre><p>It basically provides means of looking up entry objects by their
      key. A typical usage of the <code class="literal">Environment</code> can be
      illustrated with an example. </p><pre class="programlisting"><pre><span class="syntax0">...
MessageContext msgCtx <span class="syntax11">=</span> (MessageContext) <span class="syntax9">getEnvironment</span>().<span class="syntax9">getEntry</span>(MessageContext.<span class="syntax8">class</span>);
msgContext.<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
...
</span></pre></pre><p>As one can see from the example <code class="literal">Environment</code>
      will typically allow to look up implementations of the interfaces using
      their <code class="literal">Class</code> as the key (this is in fact an Aranea
      convention in using and extending the <code class="literal">Environment</code>).
      The interfaces serving as keys for <code class="literal">Environment</code>
      entries are referred to as <span class="emphasis"><em>contexts</em></span>. It is thus not
      unlike JNDI or some other directory lookups that allow to hold objects,
      however unlike them <code class="literal">Environment</code> is very specific to
      the <code class="literal">Component</code> it is given to, and can be influenced
      by its parents. In fact, all contexts available in the
      <code class="literal">Environment</code> will be provided to the
      <code class="literal">Component</code> by its parents or ancestors (in the sense
      of containment rather than inheritance). Thus, two different
      <code class="literal">Component</code>s may have completely different
      <code class="literal">Environment</code>s.</p><p>A default implementation of <code class="literal">Environment</code> is
      <code class="literal">org.araneaframework.core.StandardEnvironment</code>. It
      provides for creating an <code class="literal">Environment</code> from a
      <code class="literal">java.util.Map</code>, or extending an existing environment
      with map entries.</p><p>A component can provide an environment entry to its descendant, by
      providing it to the initializer of its direct child. For instance the
      <code class="literal">MessageContext</code> could be provided by the following
      message component:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> MessageFilterService <span class="syntax6">implements</span> MessageContext, Component, Service <span class="syntax11">{</span>
  <span class="syntax6">protected</span> Service childService;
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">setChildService</span>(Service childService) <span class="syntax11">{</span>
    <span class="syntax4">this</span>.childService <span class="syntax11">=</span> childService;
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">init</span>(Environment env) <span class="syntax11">{</span>
    childService.<span class="syntax9">init</span>(
      <span class="syntax6">new</span> <span class="syntax9">StandardEnvironment</span>(env, MessageContext.<span class="syntax8">class</span>, <span class="syntax4">this</span>);
  <span class="syntax11">}</span>

  <span class="syntax1">//MessageContext implementation...</span>
  <span class="syntax6">public</span> String <span class="syntax9">showInfoMessage</span>(String message) <span class="syntax11">{</span>
    <span class="syntax1">//Show message to user...</span>
  <span class="syntax11">}</span>  

  <span class="syntax1">//...</span>
<span class="syntax11">}</span>
</span></pre></pre><p>After that the <code class="literal">childService</code>, its children and
      so on will be able to use the <code class="literal">MessageContext</code> provided
      by <code class="literal">MessageFilterService</code>. Of course this can be done
      simpler as shown in examples in chapter</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-messaging"></a>2.3.3.&nbsp;Messaging Components</h3></div></div></div><p>So far, we have looked at the component management and
      environment. However what makes the component hierarchy such a powerful
      concept is messaging. Basically, messaging allows us to send any events
      to any component in the hierarchy (including all components or a
      specific one). The messaging is incorporated using the
      <code class="literal">org.araneaframework.Message</code> interface </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Message <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">send</span>(Object id, Component component) <span class="syntax6">throws</span> Exception;
<span class="syntax11">}</span>
</span></pre></pre><p> and <code class="literal">Component.propagate(Message message)</code>
      method. The default behavior of the <code class="literal">propagate()</code>
      method should be to send the message to all component children, passing
      the <code class="literal">send()</code> method the identifier of the child and the
      child itself. It is up to the message what to do with the child further,
      but typically <code class="literal">Message</code> just calls the
      <code class="literal">propagate()</code> method of the child passing itself as the
      argument after possibly doing some custom processing (the
      <span class="emphasis"><em>double-dispatch</em></span> OO idiom).</p><p>A standard <code class="literal">Message</code> implementation that uses
      double-dispatch to visit all the components in hierarchy is
      <code class="literal">org.araneaframework.core.BroadcastMessage</code>. It usage
      can be illustrated with the following example: </p><pre class="programlisting"><pre><span class="syntax0">...
Message myEvent <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">BroadcastMessage</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
  <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> MyEventListener)
    ((MyEventListener) component).<span class="syntax9">onMyEvent</span>(data);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
myEvent.<span class="syntax9">send</span>(<span class="syntax4">null</span>, rootComponent);
...
</span></pre></pre><p> This code will call all the components in the hierarchy
      that subscribed to the event and pass them a certain
      <code class="literal">data</code> parameter. As one can see, when calling
      <code class="literal">Message.send()</code> we will typically pass
      <code class="literal">null</code> as the first parameter, since it is needed only
      when propagating messages further down the hierarchy. Note that messages
      can be used to gather data from the components just as well as for
      passing data to them. For example one could construct message that
      gathers all <code class="literal">FormWidget</code>s from the widget
      hierarchy:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax6">static</span> <span class="syntax8">class</span> FormWidgetFinderMessage <span class="syntax6">extends</span> BroadcastMessage <span class="syntax11">{</span>
  List formList <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">ArrayList</span>();

  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> org.araneaframework.uilib.form.FormWidget) <span class="syntax11">{</span>
      formList.<span class="syntax9">add</span>(component);
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> List <span class="syntax9">getAllForms</span>() <span class="syntax11">{</span> <span class="syntax6">return</span> formList; <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Another standard <code class="literal">Message</code> implementation is
      <code class="literal">org.araneaframework.core.RoutedMessage</code>, which allows
      us to send a message to one specific component in the hierarchy as in
      the following example: </p><pre class="programlisting"><pre><span class="syntax0">...
Message myEvent <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">RoutedMessage</span>(<span class="syntax3">"a.b.c"</span>) <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    ((MyPersonalComponent) component).<span class="syntax9">myMethod</span>(...);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
myEvent.<span class="syntax9">send</span>(<span class="syntax4">null</span>, rootComponent);
...
</span></pre></pre><p> This code will send the message to the specific component
      with path "a.b.c" and call <code class="literal">myMethod()</code> on it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-persistence"></a>2.3.4.&nbsp;State and Synchronization</h3></div></div></div><p>The handling of persistent state in Aranea is very simple. There
      are no scopes and every component state is saved until it is explicitly
      removed by its parent. This does not mean that all of the components are
      bound to the session, but rather that most components will live a period
      of time appropriate for them (e.g. framework components will live as
      long as the application lives, GUI components will live until user
      leaves them, and so on). This provides for a very flexible approach to
      persistence allowing not to clutter memory with unused
      components.</p><p>The end result is that typically one needs not worry about
      persistence at all, unless one is programming some framework plug-ins.
      All class fields (except in some cases <code class="literal">transient</code>
      fields) can be assumed to persist while the host object is
      <span class="emphasis"><em>live</em></span>.</p><p>However such handling does not guarantee that the component state
      is anyhow synchronized. As a matter of fact most of the framework
      components outside the user session should be able to process concurrent
      calls and should take care of the synchronization themselves. However
      application components are typically synchronized by the framework. More
      information on the matter will follow in <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-io-data"></a>2.4.&nbsp;InputData and OutputData</h2></div></div></div><p><code class="literal">InputData</code> is Aranea abstraction for a request,
    which hides away the Servlet API and allows us to run Aranea on different
    containers (e.g. in a portlet or behind a web service).</p><p>Both <code class="literal">InputData</code> and <code class="literal">OutputData</code>
    have a <span class="emphasis"><em>scope</em></span>, which is information about the path to
    the current component. When they are propagated through the component
    hierarchy the following methods are used to construct the scope:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">pushScope(Object step)</code></td><td>Adds child identifier to the end of the current scope,
              should <span class="emphasis"><em>always</em></span> be used before the call to
              the child.</td></tr><tr><td><code class="literal">Object popScope()</code></td><td>Removes the last identifier from the scope, should
              <span class="emphasis"><em>always</em></span> be used a call to a child.</td></tr><tr><td><code class="literal">Path getScope()</code></td><td>Returns the current scope as a
              <code class="literal">Path.</code></td></tr><tr><td><code class="literal">restoreScope(Path scope)</code></td><td>Restore the scope back to a previously saved one.</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These methods should be used only when using
      <span class="emphasis"><em>Composite</em></span> components, as framework components are
      scoped differently.<code class="literal"></code></p></div><p><code class="literal">InputData</code> also provides access to the data sent
    to the component. This data comes in two flavours: </p><div class="itemizedlist"><ul type="disc" compact><li><code class="literal">getScopedData()</code>

           returns a 

          <code class="literal">java.util.Map</code>

           with the data sent specially to this component, which is associated with the current scope. 
        </li><li><code class="literal">getGlobalData()</code>

           returns a 

          <code class="literal">java.util.Map</code>

           with the data sent to the application generally. 
        </li></ul></div><p> In case Aranea is running on top of a servlet both these
    maps will contain only <code class="literal">String</code>s (or in case you
    submitted more than one value for a specific key it may contain a
    <code class="literal">String[]</code>). In case of the usual path and scope
    implementation (as dot-separated strings) <span class="emphasis"><em>global data</em></span>
    will contain the submitted parameters with no dots in them and
    <span class="emphasis"><em>scoped data</em></span> will contain the parameters prefixed with
    the current component scope string.</p><p>The main function of <code class="literal">OutputData</code> is to propagate
    attributes that are used when delegating rendering to a templating engine
    or by children to access some general information during rendering. The
    following methods are used to propagate these attributes:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">pushAttribute(Object key, Object
            value)</code></td><td>Registers the attribute <code class="literal">value</code> under the
            key <code class="literal">key</code>. If some other component have already
            propagated an attribute under this key, then it will be temporary
            overridden.</td></tr><tr><td><code class="literal">Object popAttribute(Object key)</code></td><td>Deregisters the attribute from under the key
            <code class="literal">key</code>. If the attribute was temporary overridden
            it will restore the previous attribute value.</td></tr><tr><td><code class="literal">Object getAttribute(Object key)</code></td><td>Returns the last object registered under key
            <code class="literal">key</code>.</td></tr><tr><td><code class="literal">Map getAttributes()</code></td><td>Returns all currently registered attributes.</td></tr></tbody></table></div><p>Finally, as <code class="literal">InputData</code> and
    <code class="literal">OutputData</code> are typically connected, they can be
    retrieved from the other <code class="literal">*Data</code> structure using
    correspondingly <code class="literal">getOutputData()</code> and
    <code class="literal">getInputData()</code> methods.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Since the sibling <code class="literal">*Data</code> structure is not
      propagated through the component hierarchy is not guaranteed to be
      scoped correctly!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e775"></a>2.4.1.&nbsp;Extensions</h3></div></div></div><p>InputData an OutputData both implement a way to extend their
      functionality without wrapping or extending the objects themselves. This
      is achieved by providing the following two methods:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax8">void</span> <span class="syntax9">extend</span>(Class interfaceClass, Object extension)
Object <span class="syntax9">narrow</span>(Class interfaceClass);
</span></pre></pre><p>The following example should give an idea of applying these
      methods:</p><pre class="programlisting"><pre><span class="syntax0">input.<span class="syntax9">extend</span>(FileUploadExtension.<span class="syntax8">class</span>, <span class="syntax6">new</span> <span class="syntax9">FileUploadExtension</span>(input));

...

FileUploadExtension fileUploadExt <span class="syntax11">=</span> 
  (FileUploadExtension) input.<span class="syntax9">narrow</span>(FileUploadExtension.<span class="syntax8">class</span>);
<span class="syntax6">if</span> (fileUploadExt.<span class="syntax9">uploadSucceeded</span>()) <span class="syntax11">{</span>
  <span class="syntax1">//...</span>
<span class="syntax11">}</span>
</span></pre></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Both <code class="literal">HttpServletRequest</code> and
        <code class="literal">HttpServletResponse</code> are available as
        <code class="literal">InputData</code> and <code class="literal">OutputData</code>
        extensions respectively.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e803"></a>2.4.2.&nbsp;HttpInputData and HttpOutputData</h3></div></div></div><p>Although all of the core Aranea abstractions are independent of
      the Servlet API and web in general, we also provide a way to manipulate
      low-level HTTP constructs. To that goal we provide to interfaces,
      <code class="literal">HttpInputData</code> and <code class="literal">HttpOutputData</code>,
      which extend respectively <code class="literal">InputData</code> and
      <code class="literal">OutputData</code>.</p><p>Let's examine the <code class="literal">HttpInputData</code>. First of all
      it provides methods that are similar to the ones found in the
      <code class="literal">HttpServletRequest</code>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">Iterator getParameterNames()</code></td><td>Returns an iterator over names of the parameters
                submitted with the current request.</td></tr><tr><td><code class="literal">String[] getParameterValues(String
                name)</code></td><td>Returns the array of values of the particular parameter
                submitted with the current request.</td></tr><tr><td><code class="literal">String
                getCharacterEncoding()</code></td><td>Returns the character encoding that is used to decode
                the request parameters.</td></tr><tr><td><code class="literal">setCharacterEncoding(String
                encoding)</code></td><td>Sets the character encoding that is used to decode the
                request parameters. Note that this must be called before any
                parameters are read according to the Servlet
                specification.</td></tr><tr><td><code class="literal">String getContentType()</code></td><td>Returns the MIME content type of the request body or
                <code class="literal">null</code> if the body is lacking.</td></tr><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the preferred Locale that the client will
                accept content in, based on the Accept-Language header. If the
                client request doesn't provide an Accept-Language header, this
                method returns the default locale for the server.</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Unlike <code class="literal">InputData</code> methods the parameters are
        presented as is and include both global and scoped parameters (the
        scoped ones are prefixed by the full name of the enclosing
        widget).</p></div><p>However next methods are a bit different from the
      <code class="literal">HttpServletRequest</code> alternatives:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">String getRequestURL()</code></td><td>Returns the target URL of the current request.</td></tr><tr><td><code class="literal">String getContainerURL()</code></td><td>Returns an URL pointing to the Aranea container (in
                most cases the dispatcher servlet).</td></tr><tr><td><code class="literal">String getContextURL()</code></td><td>Returns an URL pointing to the Aranea container context
                (in most cases the web application root).</td></tr><tr><td><code class="literal">String getPath()</code></td><td>Returns the path on the server starting from the
                dispatcher servlet that has been submitted as the part of the
                request target URL.</td></tr><tr><td><code class="literal">pushPathPrefix(String
                pathPrefix)</code></td><td>Consumes the path prefix allowing children to be mapped
                to a relative path.</td></tr><tr><td><code class="literal">popPathPrefix()</code></td><td>Restores the previously consumed path prefix.</td></tr></tbody></table></div><p>The interesting part here are the methods that deal with the path.
      The problem is that unlike most common cases Aranea components form a
      hierarchy. Therefore if a parent is mapped to path prefix "myPath/*" and
      its child is mapped to a path prefix "myChildPath/*" if the path
      handling were absolute the child would never get the mapped calls. This
      is due to the child being really mapped to the path
      "myPath/myChildPath". Therefore the parent must consume the prefix
      "myPath/" using method <code class="literal">pushPathPrefix()</code> and then the
      child will be correctly matched to the relative path
      "myChildPath".</p><p><code class="literal">HttpOutputData</code> contains methods that are
      comparable to the ones found in
      <code class="literal">HttpServletResponse</code>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">String encodeURL(String url)</code></td><td>Encodes the URL to include some additional information
                (e.g. HTTP session identifier). Note that Aranea may include
                some information not present in the servlet spec.</td></tr><tr><td><code class="literal">sendRedirect(String
                location)</code></td><td>Sends an HTTP redirect to a specified location
                URL.</td></tr><tr><td><code class="literal">OutputStream
                getOutputStream()</code></td><td>Returns an <code class="literal">OutputStream</code> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</td></tr><tr><td><code class="literal">PrintWriter getWriter()</code></td><td>Returns a <code class="literal">PrintWriter</code> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</td></tr><tr><td><code class="literal">setContentType(String type)</code></td><td>Sets the MIME content type of the output. May include
                the charset, e.g. "text/html; charset=UTF-8".</td></tr><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the locale associated with the
                response.</td></tr><tr><td><code class="literal">String
                getCharacterEncoding()</code></td><td>Returns the character encoding used to write out the
                response.</td></tr><tr><td><code class="literal">void setCharacterEncoding(String
                encoding)</code></td><td>Sets the character encoding used to write out the
                response.</td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-services"></a>2.5.&nbsp;Services</h2></div></div></div><p><code class="literal">org.araneaframework.Service</code> is a basic
    abstraction over an event-driven <span class="emphasis"><em>Controller</em></span> pattern
    that inherits life cycle, environment and messaging from the
    <code class="literal">Component</code>. The difference from the
    <code class="literal">Component</code> is as follows: </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Service <span class="syntax6">extends</span> Component, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getService</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(Path path, InputData input, OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>The method <code class="literal">action()</code> is similar to the
    <code class="literal">service()</code> method in the Servlet API,
    <code class="literal">InputData</code> being an abstraction over a request and
    <code class="literal">OutputData</code> being an abstraction over a response (see
    <a href="core.html#core-io-data" title="2.4.&nbsp;InputData and OutputData">Section&nbsp;2.4, &#8220;InputData and OutputData&#8221;</a>). Thus a service will both process the
    request parameters and render itself during this method call. However
    unlike servlets services can be <span class="emphasis"><em>Composite</em></span> and may be
    defined both statically (on application startup) or dynamically
    (adding/removing new services on the fly).</p><p>Services are the basic working horses of the Aranea framework. They
    can generally be both synchronized and unsynchronized depending on the
    context. Services may also have persistent state and their lifetime is
    explicitly managed by their parent (see <a href="core.html#components-persistence" title="2.3.4.&nbsp;State and Synchronization">Section&nbsp;2.3.4, &#8220;State and Synchronization&#8221;</a>). The service life cycle is very
    simple&#8212;as long as the service is live and enabled it can receive
    <code class="literal">action()</code> calls, possibly several at a time.</p><p>Aranea provides a base implementation of the
    <code class="literal">Service</code> &#8212;
    <code class="literal">org.araneaframework.core.BaseService</code> and a base class
    for application development
    <code class="literal">org.araneaframework.core.BaseApplicationService</code>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1071"></a>2.5.1.&nbsp;Filter Services</h3></div></div></div><p>One of the most common ways to use the services it to create a
      filter service, that wraps a child service and provides some additional
      functionality and/or environment entries. To that purpose Aranea
      provides a filter base class &#8212;
      <code class="literal">org.araneaframework.framework.core.BaseFilterService</code>.
      This class implements all of the Service methods, by default just
      delegating them to the corresponding child methods. A common thing to do
      is override the <code class="literal">action()</code> method to add functionality
      and <code class="literal">getChildEnvironment()</code> to add environment entries,
      as shown in the following example:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> StandardSynchronizingFilterService 
  <span class="syntax6">extends</span> BaseFilterService <span class="syntax11">{</span>
  
  <span class="syntax6">protected</span> Environment <span class="syntax9">getChildEnvironment</span>() <span class="syntax11">{</span>
    <span class="syntax6">return</span> <span class="syntax6">new</span> <span class="syntax9">StandardEnvironment</span>(
        <span class="syntax9">getEnvironment</span>(), 
        SynchronizingContext.<span class="syntax8">class</span>, 
        <span class="syntax6">new</span> <span class="syntax9">SynchronizingContext</span>() <span class="syntax11">{}</span>);
  <span class="syntax11">}</span>
  
  <span class="syntax6">protected</span> <span class="syntax6">synchronized</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(
      Path path, 
      InputData input, 
      OutputData output) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax4">super</span>.<span class="syntax9">action</span>(path, input, output);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>More information on services and other components that make up the
      framework can be found in <a href="framework.html" title="Chapter&nbsp;3.&nbsp;Framework and Configuration">Chapter&nbsp;3, <i>Framework and Configuration</i></a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-widgets"></a>2.6.&nbsp;Widgets</h2></div></div></div><p><span class="emphasis"><em>Widget</em></span> is the main abstraction used to program
    applications in Aranea. Widget is specifically any class extending the
    <code class="literal">org.araneaframework.Widget</code> interface and adhering to a
    number of conventions. More generally, widgets are components that
    function both as controllers and GUI elements, and that have the following
    properties: </p><div class="variablelist"><dl><dt><span class="term">Synchronized</span></dt><dd>
             The widget is always accessed by a single thread, therefore there is never any need to think about synchronization. One can assume that there is only one user using the application and program to service this user without any concern for concurrency. 
          </dd><dt><span class="term">Stateful</span></dt><dd>
             When programming widgets there is no need to concern oneself with juggling the 

            <code class="literal">HttpSession</code>

             attributes or similar low-level mechanics. Widget state (meaning the class fields) is guaranteed to be preserved as long as the widget is alive. One can just use these fields to save the necessary data without any external state management, thus adhering to the rules of object-oriented encapsulation. 
          </dd></dl></div><p>The latter two properties make widgets ideal for
    programming custom application components.</p><p>Widgets extend services with a request-response cycle:
    </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Widget <span class="syntax6">extends</span> Service, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getWidget</span>();
  
  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">update</span>(InputData data) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">event</span>(Path path, InputData input) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">process</span>() <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">render</span>(OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span> 
<span class="syntax11">}</span>
</span></pre></pre><p>Although widgets extend services, a widget will function during one
    request either as a widget or as a service&#8212;that is if a widget receives an
    <code class="literal">action()</code> call no other request-response cycle calls can
    occur.</p><p>The widget request-response cycle proceeds as follows: </p><div class="orderedlist"><ol type="1" compact><li><code class="literal">update()</code>

           &#8212;this method is called for all the widgets in the hierarchy. It allows widgets to read the data from request and possibly store some conversation state or at least temporary information to render the next view. 
        </li><li><code class="literal">event()</code>

           &#8212;this method is called on only one widget in the hierarchy. It allows to send widgets events from the user. The 

          <code class="literal">path</code>

           is used to route the event to the correct widget and is empty when the event is delivered to its endpoint. This method is optional in the widget request-response cycle. 
        </li><li><code class="literal">process()</code>

           &#8212;this method is called on all the widgets in the hierarchy. It allows widgets to process the result of 

          <code class="literal">event()</code>

           and 

          <code class="literal">update()</code>

           calls before rendering. 
        </li><li><code class="literal">render()</code>

           &#8212;the way this method is called depends on how widgets are rendered (see 

          <a href="core.html#components-render" title="2.6.1.&nbsp;ViewModel and Rendering">Section&nbsp;2.6.1, &#8220;ViewModel and Rendering&#8221;</a>

           ). It may be called only after 

          <code class="literal">process()</code>

           and may be called more than once (or not at all) during one request-response cycle. 
        </li></ol></div><p>Aranea provides a base implementation of the
    <code class="literal">Widget</code>&#8212;<code class="literal">org.araneaframework.core.Base</code>Widget
    and a base class for application development
    <code class="literal">org.araneaframework.core.BaseApplicationWidget</code>. More on
    the last one can be found in <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-render"></a>2.6.1.&nbsp;ViewModel and Rendering</h3></div></div></div><p>The default model of both widget and service rendering is that
      they render themselves. However, in most cases the widget might want to
      delegate the rendering to some templating language. In some other cases
      the widget might be rendered externally, without calling
      <code class="literal">render()</code> at all. Further on, we will describe these
      three cases in detail. </p><div class="variablelist"><dl><dt><span class="term">Self-rendering</span></dt><dd>
               In the most basic situation the widget will just use 

              <code class="literal">OutputData</code>

               for rendering by casting it into e.g. 

              <code class="literal">HttpOutputData</code>

               . In such a case the widget will just write out markup and return from the 

              <code class="literal">render()</code>

               method optionally rendering children as well. The data for rendering will be drawn from the widget fields as well as (possibly) 

              <code class="literal">OutputData</code>

               attributes. 
            </dd><dt><span class="term">Using templates for rendering</span></dt><dd>
               The most common case in application widgets is to delegate rendering to a templating language. A widget may basically choose to render itself in arbitrary templating language as Aranea does not impose any restrictions. In fact, one widget may be rendered with one templating language, while another one with a completely different language. The template can gain access to the widget using the knowledge of the widget's full name (which is gathered in the 

              <code class="literal">OutputData</code>

               scope). It is then possible to acquire the widget View Model, which is a read-only representation of the widget state. For that the widget should implement 

              <code class="literal">org.araneaframework.Viewable</code>

               : 

              <pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Viewable <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getViewable</span>();

  <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Object <span class="syntax9">getViewModel</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>  
<span class="syntax11">}</span>
</span></pre></pre>

               View model is put together by the widget being rendered and should contain all the data necessary to render the widget. 
            </dd><dt><span class="term">External rendering</span></dt><dd><p>Finally, a widget <code class="literal">render()</code> method may
              not be called altogether and a <code class="literal">Viewable</code>
              widget may be rendered externally using the available View
              Model. This is the case with some reusable widgets which are
              rendered using e.g. JSP tags.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-application-widgets"></a>2.7.&nbsp;Application Widgets</h2></div></div></div><p>This section explains how to program applications using widgets as
    the main abstraction.</p><p>A typical application widget class will extend
    <code class="literal">org.araneaframework.uilib.core.BaseUIWidget</code>. This
    widget represents the usual custom application component that is rendered
    using Aranea custom JSP tags. <code class="literal">BaseUIWidget</code> inherits
    most of its functionality from
    <code class="literal">org.araneaframework.core.BaseApplicationWidget</code> the
    difference between the two being only that <code class="literal">BaseUIWidget</code>
    assumes to be connected with a JSP page (or another templating
    toolkit).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1243"></a>2.7.1.&nbsp;Children Management</h3></div></div></div><p><code class="literal">BaseApplicationWidget</code> provides a number of
      methods for managing child widgets:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax6">abstract</span> <span class="syntax8">class</span> BaseApplicationWidget ... <span class="syntax11">{</span>
  ...
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">addWidget</span>(Object key, Widget child);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">removeWidget</span>(Object key);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">enableWidget</span>(Object key);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">disableWidget</span>(Object key);
  ...
<span class="syntax11">}</span>
</span></pre></pre><p>As one can see, every added child has an identifier which should
      be unique among its siblings. This identifier is used when rendering and
      sending events to the widget in question, to identify it among its
      peers.</p><p>Typically, children are added when created:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addWidget</span>(<span class="syntax3">"myChildWidget"</span>, <span class="syntax6">new</span> <span class="syntax9">MyChildWidget</span>(<span class="syntax3">"String parameter"</span>, <span class="syntax12">1</span>));
</span></pre></pre><p>An added child will be initialized, will receive updates and
      events and may be rendered. A widget can be active only if added to a
      parent. It will live as long as the parent, unless the parent explicitly
      removes it:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">removeWidget</span>(<span class="syntax3">"myChildWidget"</span>);
</span></pre></pre><p>Removing a child widget will destroy it and one should also
      dispose of any references that may be pointing to it, to allow the child
      to be garbage collected.</p><p>A usual idiom is to save a reference to the newly created and
      added child using a parent widget field:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> MyWidget <span class="syntax6">extends</span> BaseUIWidget <span class="syntax11">{</span>
  <span class="syntax6">private</span> MyChildWidget myChildWidget;
  
  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax11">{</span>
    myChildWidget <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">MyWidget</span>(<span class="syntax3">"String parameter"</span>, <span class="syntax12">1</span>);
    <span class="syntax9">addWidget</span>(<span class="syntax3">"myChildWidget"</span>, myChildWidget);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>This allows to call directly child widget methods and does not
      anyhow significantly increase memory usage, so this technique may be
      used everywhere when needed.</p><p>Disabling a child
      (<code class="literal">disableWidget("myChildWidget")</code>) will stop it from
      receiving any events or rendering, but will not destroy it. It can later
      be reenabled by calling
      <code class="literal">enableWidget("myChildWidget")</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1282"></a>2.7.2.&nbsp;Event Listeners</h3></div></div></div><p>Registering event listeners allows widgets to subscribe to some
      specific user events (widget will receive only events specially sent to
      it). The distinction comes by the "event identifier" that is assigned to
      an event when sending it. The events are handled by the classes
      extending
      <code class="literal">org.araneaframework.core.EventListener</code>:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> EventListener <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, InputData input) <span class="syntax6">throws</span> Exception;
<span class="syntax11">}</span>
</span></pre></pre><p>The event listeners are registered as following:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">EventListener</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, InputData input) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event: "</span> <span class="syntax11">+</span> eventId);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Of course, the event listener does not have to be an anonymous
      class and can just as well be an inner or even a usual public class. A
      standard base implementation
      <code class="literal">org.araneaframework.core.StandardEventListener</code> is
      provided that receives an optional <code class="literal">String</code> event
      parameter:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">StandardEventListener</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, String eventParam, InputData input) <span class="syntax6">throws</span> Exception;
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event "</span> <span class="syntax11">+</span> eventId <span class="syntax11">+</span> <span class="syntax3">" with parameter "</span> <span class="syntax11">+</span> parameter);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Another useful way to process events is to register a proxy event
      listener
      (<code class="literal">org.araneaframework.core.ProxyEventListener</code>) that
      will proxy the event to a method call, e.g.:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax11">{</span>
  <span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">ProxyEventListener</span>(<span class="syntax4">this</span>));
<span class="syntax11">}</span>

<span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">handleEventMyEvent</span>(String parameter) <span class="syntax11">{</span>
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event myEvent with parameter "</span> <span class="syntax11">+</span> parameter);
<span class="syntax11">}</span>
</span></pre></pre><p>The convention is that the proxy event listener translates an
      event "&lt;event&gt;" into a method call
      <code class="literal">handleEvent&lt;event&gt;</code> making the first letter of
      &lt;event&gt; uppercase. The <code class="literal">"String parameter</code>" is
      optional and can be omitted.</p><p>A useful feature is the method
      <code class="literal">setGlobalEventListener(EventListener listener)</code> that
      allows to register a listener that will receive all events sent to the
      widget. In fact <code class="literal">BaseUIWidget</code> does that by default,
      and typically you will use the individual event listeners only when you
      want to override this default behaviour. This allows to just define
      correct method names (<code class="literal">handleEvent&lt;event&gt;</code>) and
      all events will be translated to the calls to these methods. Certainly
      this can also be cancelled by calling
      <code class="literal">clearGlobalEventListener()</code>, or overridden by adding
      your own global event listener.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1339"></a>2.7.3.&nbsp;Action Listeners</h3></div></div></div><p>Registering action listeners allows widgets to subscribe to some
      specific user generated actions. Actions differ from events in that
      widget lifecycle execution for whole component tree is not triggered
      upon request&#8212;actions are just sent to the receiving widget's <span class="emphasis"><em>ActionListener</em></span>, 
      which is SOLELY responsible for generating the whole response. For rich UI components this allows a quick
      conversations with server, without requiring full form submits and generating whole view.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widgets-environment"></a>2.7.4.&nbsp;Environment</h3></div></div></div><p>Every initialized widget has a reference to
      <code class="literal">org.araneaframework.Environment</code> available through the
      <code class="literal">getEnvironment()</code> method. Environment allows to look
      up framework services (called <span class="emphasis"><em>contexts</em></span>):</p><pre class="programlisting"><pre><span class="syntax0">MessageContext msgCtx <span class="syntax11">=</span> (MessageContext) <span class="syntax9">getEnvironment</span>().<span class="syntax9">getEntry</span>(MessageContext.<span class="syntax8">class</span>);
msgCtx.<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
</span></pre></pre><p>As one can see from the examples, contexts are looked up using
      their interface <code class="literal">Class</code> object as key. All framework
      services in Aranea are accessible only using the environment.</p><p>To find out more about <code class="literal">InputData</code> and
      <code class="literal">OutputData</code> see <a href="core.html#core-environment" title="2.3.2.&nbsp;Environment">Section&nbsp;2.3.2, &#8220;Environment&#8221;</a></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1378"></a>2.7.5.&nbsp;Overridable Methods</h3></div></div></div><p>The main method that is typically overridden in a widget is
      <code class="literal">init()</code>. As widget does not get an environment before
      it is added and initialized it is impossible to access framework
      services in the constructor, therefore most of the initialization logic
      moves to the custom <code class="literal">init()</code> method. A dual overridable
      method is <code class="literal">destroy()</code>, though it is used much
      less.</p><p>In addition to event processing it is sometimes useful to do some
      kind of pre- and post-processing. The
      <code class="literal">BaseApplicationWidget</code> has the following methods that
      may be overridden to allow this processing:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">handleUpdate</span>(InputData input) <span class="syntax6">throws</span> Exception <span class="syntax11">{}</span>
<span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">handleProcess</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{}</span>
</span></pre></pre><p><code class="literal">handleUpdate()</code> is called before event listeners
      are notified and allows to read and save request data preparing it for
      the event. More importantly, this method is called even when no event is
      sent to the current widget allowing one to submit some data to any
      widget. <code class="literal">handleProcess()</code> is called after the event
      listeners are notified and again is called event if current widgets
      receives no events at all. It allows to prepare the widget for
      rendering, post-processing the request results without concern whether
      or not events have been delivered.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1407"></a>2.7.6.&nbsp;InputData and OuputData</h3></div></div></div><p>In Aranea one usually does not need to handle request manually in
      custom application widgets. Even more, the request is not accessible by
      default. The usual way to submit custom data to a widget and read it is
      using Aranea Forms (see <a href="forms.html" title="Chapter&nbsp;5.&nbsp;Forms and Data Binding">Chapter&nbsp;5, <i>Forms and Data Binding</i></a>). However, when one
      needs to access the submitted data, one can do that using the
      <code class="literal">org.araneaframework.InputData</code>. This class can be used
      as follows: </p><pre class="programlisting"><pre><span class="syntax0">...
String myData1 <span class="syntax11">=</span> 
  (String) <span class="syntax9">getInputData</span>().<span class="syntax9">getScopedData</span>().<span class="syntax9">get</span>(<span class="syntax3">"myData1"</span>);
String globalSubmittedParameter <span class="syntax11">=</span> 
  (String) <span class="syntax9">getInputData</span>().<span class="syntax9">getGlobalData</span>().<span class="syntax9">get</span>(<span class="syntax3">"globalSubmittedParameter"</span>);
...
</span></pre></pre><p> <code class="literal">getInputData()</code> is a
      <code class="literal">BaseApplicationWidget</code> method that returns the input
      data for the current request (one can also use the
      <code class="literal">input</code> parameter given to event listener
      directly).</p><p><code class="literal">org.araneaframework.OutputData</code> is accessible
      through the <code class="literal">getOutputData()</code> method of
      <code class="literal">BaseWidget</code> or directly as the
      <code class="literal">output</code> parameter passed to
      <code class="literal">render()</code> method.</p><p>To find out more about <code class="literal">InputData</code> and
      <code class="literal">OutputData</code> see <a href="core.html#core-io-data" title="2.4.&nbsp;InputData and OutputData">Section&nbsp;2.4, &#8220;InputData and OutputData&#8221;</a></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widget-view-selector"></a>2.7.7.&nbsp;View Model and Rendering</h3></div></div></div><p><code class="literal">BaseApplicationWidget</code> also contains methods
      that facilitate transferring data to the presentation layer. This is
      achieved using a <span class="emphasis"><em>View model</em></span>&#8212;an object containing a
      snapshot of the widget current state. The most typical way to use the
      view model it to add data to it:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">putViewData</span>(<span class="syntax3">"today"</span>, <span class="syntax6">new</span> <span class="syntax9">Date</span>());
<span class="syntax9">putViewData</span>(<span class="syntax3">"currentUser"</span>, userBean);
...
</span></pre></pre><p>View data is typically accessible in the presentation layer as
      some kind of a variable (e.g. a JSP EL variable) for the current widget.
      If the data becomes outdated one can override it using
      <code class="literal">putViewData()</code> call or remove it using the
      <code class="literal">removeViewData()</code> call. In case one needs to put view
      data that would last one request only there is an alternative
      method:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">putViewDataOnce</span>(<span class="syntax3">"now"</span>, <span class="syntax6">new</span> <span class="syntax9">Date</span>());
...
</span></pre></pre><p>Finally widget instance is also visible to the view, so one of the
      ways to make some data accessible is just to define a JavaBean style
      getter:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax6">public</span> Date <span class="syntax9">getNow</span>() <span class="syntax11">{</span>
  <span class="syntax6">return</span> <span class="syntax6">new</span> <span class="syntax9">Date</span>();
<span class="syntax11">}</span>
...
</span></pre></pre><p><code class="literal">BaseUIWidget</code> allows to render the
      current widget using a JSP page. To do that one needs to select a view
      as follows:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">setViewSelector</span>(<span class="syntax3">"myWidget/form"</span>);
...
</span></pre></pre><p>This code makes the widget render itself using the JSP situated in
      <code class="literal">WEB-INF/jsp/myWidget/form.jsp</code> (of course the exact
      place is configurable). It is also possible to render the widget using
      other template technologies with the same view selector by overriding
      the <code class="literal">render()</code> method in the base project
      widget.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widgets-example-widget"></a>2.7.8.&nbsp;Putting It All Together</h3></div></div></div><p>A typical application custom widget will look like that:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> TestWidget <span class="syntax6">extends</span> BaseUIWidget <span class="syntax11">{</span>

  <span class="syntax6">private</span> <span class="syntax6">static</span> <span class="syntax6">final</span> Logger log <span class="syntax11">=</span> Logger.<span class="syntax9">getLogger</span>(TestWidget.<span class="syntax8">class</span>);
  
  <span class="syntax6">private</span> Data data;
  
  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax1">//Sets the JSP for this widget to "/WEB-INF/jsp/home.jsp"</span>
    <span class="syntax9">setViewSelector</span>(<span class="syntax3">"home"</span>);
    
    <span class="syntax1">//Get data from the business layer</span>
    data <span class="syntax11">=</span> ((TestService) <span class="syntax9">lookupService</span>(<span class="syntax3">"testService"</span>)).<span class="syntax9">getData</span>(<span class="syntax3">"test parameter"</span>);
    
    <span class="syntax1">//Make the data accessible to the JSP for rendering</span>
    <span class="syntax9">putViewData</span>(<span class="syntax3">"myData"</span>, data);    
  <span class="syntax11">}</span>
  
  <span class="syntax1">/*</span>
<span class="syntax1">   * Event listener method that will process "test" event.</span>
<span class="syntax1">   */</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">handleEventTest</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Test event received successfully"</span>);       
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1505"></a>2.8.&nbsp;Standard Contexts</h2></div></div></div><p>Contexts are the Aranea way to access framework services. They can
    be looked up from the environment as shown in <a href="core.html#widgets-environment" title="2.7.4.&nbsp;Environment">Section&nbsp;2.7.4, &#8220;Environment&#8221;</a>. This section describes the most common
    Aranea contexts that should be available in any typical configuration. All
    these contexts are also available directly through
    <code class="literal">BaseUIWidget</code> methods as shown further on.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="MessageContext"></a>2.8.1.&nbsp;MessageContext</h3></div></div></div><p><code class="literal">org.araneaframework.framework.MessageContext</code>
      allows to show messages to the user. The messages can be of several
      types, including predefined error and informative types. Typically
      messages will be shown somewhere in the application (exact way is
      application-specific). <code class="literal">MessageContext</code> is available
      through a <code class="literal">BaseUIWidget</code> method
      <code class="literal">getMessageCtx()</code> and is typically used as
      follows:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
</span></pre></pre><p><code class="literal">MessageContext</code> divides messages by type (with
      predefined "info", "warning" and "error" types available) and life span
      (usual or permanent). Usual messages are shown to user once and then
      cleared, while permanent messages will be shown to user until explicitly
      cleared by the programmer:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">showMessage(String type, String
                message)</code></td><td>Shows a message <code class="literal">message</code> of type
                <code class="literal">type</code> to the user. Message is cleared after
                the user sees it once.</td></tr><tr><td><code class="literal">showInfoMessage(String
                message)</code></td><td>Shows an error message to the user.</td></tr><tr><td><code class="literal">showWarningMessage(String
                message)</code></td><td>Shows a warning message to the user.</td></tr><tr><td><code class="literal">showErrorMessage(String
                message)</code></td><td>Shows an informative message to the user.</td></tr><tr><td><code class="literal">clearMessages()</code></td><td>Clears all non-permanent messages.</td></tr><tr><td><code class="literal">showPermanentMessage(String type, String
                message)</code></td><td>Shows a permanent message <code class="literal">message</code> of
                type <code class="literal">type</code> to the user. The message will be
                shown until hidden explicitly.</td></tr><tr><td><code class="literal">hidePermanentMessage(String
                message)</code></td><td>Clears the specific permanent message, under all
                message types where it might be present.</td></tr><tr><td><code class="literal">clearPermanentMessages()</code></td><td>Clears all of the permanent messages.</td></tr><tr><td><code class="literal">clearAllMessages()</code></td><td>Clears all messages (both permanent and usual).</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Messages should already be localized when passed to the
        <code class="literal">MessageContext</code>, it does not do any further
        processing. Use <code class="literal">LocalizationContext</code> described in
        <a href="core.html#LocalizationContext" title="2.8.2.&nbsp;LocalizationContext">Section&nbsp;2.8.2, &#8220;LocalizationContext&#8221;</a> to do the actual localization
        of the added message.</p></div><p>For information on implementation of the
      <code class="literal">MessageContext</code> see <a href="framework.html#araneaMessagingFilter" title="3.5.8.&nbsp;User Messages Filter">Section&nbsp;3.5.8, &#8220;User Messages Filter&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="LocalizationContext"></a>2.8.2.&nbsp;LocalizationContext</h3></div></div></div><p><code class="literal">org.araneaframework.framework.LocalizationContext</code>
      allows to get and set current session locale, localize strings and
      messages, and lookup resource bundles. The context is available through
      the <code class="literal">BaseUIWidget</code> method
      <code class="literal">getL10nCtx()</code>. Typically it is used as follows:</p><pre class="programlisting"><pre><span class="syntax0">
...
String message <span class="syntax11">=</span> <span class="syntax9">getL10nCtx</span>().<span class="syntax9">localize</span>(<span class="syntax3">"my.message.key"</span>);
<span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(message);
...
</span></pre></pre><p><code class="literal">LocalizationContext</code> provides the following
      methods:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the current session locale.</td></tr><tr><td><code class="literal">setLocale(Locale locale)</code></td><td>Sets the current session locale.</td></tr><tr><td><code class="literal">String localize(String key)</code></td><td>Localizes a string returning one that corresponds to
                the current locale.</td></tr><tr><td><code class="literal">ResourceBundle
                getResourceBundle()</code></td><td>Returns a resource bundle corresponding to the current
                locale.</td></tr><tr><td><code class="literal">ResourceBundle getResourceBundle(Locale
                locale)</code></td><td>Returns a resource bundle corresponding to arbitrary
                locale.</td></tr><tr><td><code class="literal">String getMessage(String code, Object[]
                args)</code></td><td>Localizes the code and uses it to format the message
                with the passed arguments. The format of the localized message
                should be acceptable by
                <code class="literal">java.text.MessageFormat</code>.</td></tr><tr><td><code class="literal">String getMessage(String code, Object[] args,
                String defaultMessage)</code></td><td>Localizes the code and uses it to format the message
                with the passed arguments. The format of the localized message
                should be acceptable by
                <code class="literal">java.text.MessageFormat</code>. If the localized
                message cannot be resolved uses
                <code class="literal">defaultMessage</code> instead.</td></tr></tbody></table></div><p>For information on implementation of the
      <code class="literal">LocalizationContext</code> see <a href="integration.html#araneaLocalizationFilter" title="8.1.2.&nbsp;Spring Localization Filter">Section&nbsp;8.1.2, &#8220;Spring Localization Filter&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="FlowContext"></a>2.8.3.&nbsp;FlowContext</h3></div></div></div><p>A common need in a web programming is to support navigation style
      known as <span class="emphasis"><em>flows</em></span>&#8212;interactive stateful processes that
      can navigate to each other passing arguments when needed. A more complex
      case is when we also have flow nesting&#8212;a flow can call a subflow, and
      wait for it to finish, then reactivate again. In this case we can have
      at any given moment a stack of flows, where the top one is active, and
      the next one will reactivate when the top one finishes. It is also
      useful if nested flows can return resulting values when they
      finish.</p><div class="figure"><a name="d0e1733"></a><div class="mediaobject"><img src="../images/flows.png" alt="Flow diagram"></div><p class="title"><b>Figure&nbsp;2.2.&nbsp;Flow diagram</b></p></div><p><code class="literal">org.araneaframework.framework.FlowContext</code> is
      the Aranea context that provides support for nested flow navigation.
      Aranea flow is a widget that is running in the flow container (using the
      <code class="literal">FlowContext.start()</code> method. Aranea abstraction for
      the nested state is that of a function&#8212;the nested
      <span class="emphasis"><em>flow</em></span> takes in some parameters and when finished may
      return some value or signal that no value can be returned. The context
      is available as <code class="literal">getFlowCtx()</code> method of
      <code class="literal">BaseUIWidget</code> and allows to start flows, finish flows
      and return the resulting value.</p><p>To start a new flow one needs to create a widget as usual. The
      widget may take some parameters in the constructor&#8212;they are considered
      to be the incoming parameters of the flow:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)), <span class="syntax4">null</span>, <span class="syntax4">null</span>);
...
</span></pre></pre><p>This call will start a new nested flow for the widget
      <code class="literal">TestFlow</code> making the current flow inactive.
      <code class="literal">TestFlow</code> will render and receive event until it
      explicitly returns control to the starting flow. Note that this code
      will start the flow and then return the control, so it is important not
      to do anything in the same method after starting a new flow.</p><p>To end the flow successfully one needs to do as follows:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">finish</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">8</span>));
...
</span></pre></pre><p>This call will finish the current flow (in our case
      <code class="literal">TestFlow</code>) and return the control to the starting flow
      and its widget.</p><p>Often one needs to handle the return from the flow, processing the
      returned result. This corresponds to our abstraction of a method,
      however since Java does not support continuations we chose to allow the
      caller to register a handler when starting the flow by passing a
      <code class="literal">FlowContext.Handler</code>:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)), <span class="syntax4">null</span>, 
  <span class="syntax6">new</span> FlowContext.<span class="syntax9">Handler</span>() <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">onFinish</span>(Object result) <span class="syntax11">{</span>
      <span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"TestFlow returned value "</span> <span class="syntax11">+</span> result);
    <span class="syntax11">}</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">onCancel</span>() <span class="syntax11">{</span>
      <span class="syntax1">//Ignore cancelled flow</span>
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>);
...
</span></pre></pre><p></p><p>A less common but nevertheless useful feature is to configure the
      starting flow after it has been initialized. For that the caller needs
      to pass a <code class="literal">FlowContext.Configurator</code>:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)), 
  <span class="syntax6">new</span> FlowContext.<span class="syntax9">Configurator</span>() <span class="syntax11">{</span>
     <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">configure</span>(Component comp) <span class="syntax11">{</span>
      ((TestFlow) comp).<span class="syntax9">setStrategy</span>(TestFlow.ATTACK);
     <span class="syntax11">}</span>
  <span class="syntax11">}</span>, <span class="syntax4">null</span>);
...
</span></pre></pre><p></p><p>Finally <code class="literal">FlowContext</code> also allows to replace the
      current flow instead of deactivating it by using the
      <code class="literal">replace()</code> method and to cancel the current flow by
      using the <code class="literal">cancel()</code> method.</p><p>For standard implementation, please see <a href="framework.html#araneaRootFlowContainer" title="3.5.19.&nbsp;Root Flow Container">Section&nbsp;3.5.19, &#8220;Root Flow Container&#8221;</a></p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="intro.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="framework.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Introduction&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Framework and Configuration</td></tr></table></div></body></html>