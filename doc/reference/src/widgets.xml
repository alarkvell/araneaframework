<!--
  Copyright 2006 Webmedia Group Ltd.
 
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<chapter id="widgets">
	<title>Programming with Widgets</title>
  
	<sect1>
		<title>Overview</title>

    <para>
      <emphasis>Widget</emphasis> is the main abstraction used to program applications in Aranea. Widget is specifically any class extending the <literal>org.araneaframework.Widget</literal> interface and adhering to a number of conventions. More generally, widgets are components that function both as controllers and GUI elements, and that have the following properties:
      <variablelist>
        <varlistentry>
          <term>Synchronized</term>
          <listitem>
            The widget is always accessed by a single thread, therefore there is never any need to think about synchronization. One can assume that there is only one user using the application and program to service this user without any concern for concurrency.
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Stateful</term>
          <listitem>
            When programming widgets there is no need to concern oneself with juggling the <literal>HttpSession</literal> attributes or similar low-level mechanics. Widget state (meaning the class fields) is guaranteed to be preserved as long as the widget is alive. One can just use these fields to save the necessary data without any external state management, thus adhering to the rules of object-oriented encapsulation, .
          </listitem>
        </varlistentry>
      </variablelist>
      The latter two properties make widgets ideal for programming custom application components. 
    </para>
	
  </sect1>
	<sect1>
		<title>BaseApplicationWidget &amp; BaseUIWidget</title>

    <para>
      A typical widget class will extend <literal>org.araneaframework.uilib.core.BaseUIWidget</literal>. This widget represents the usual custom application component that is rendered using Aranea custom JSP tags. <literal>BaseUIWidget</literal> inherits most of its functionality from <literal>org.araneaframework.core.BaseApplicationWidget</literal> the difference between the two being only that <literal>BaseUIWidget</literal> assumes to be connected with a JSP page.
    </para>

    <sect2>
      <title>Children management</title>

      <para>
        <literal>BaseApplicationWidget</literal> provides a number of methods for managing child widgets:
        <programlisting role="java">public abstract class BaseApplicationWidget ... {
  ...
  public void addWidget(Object key, Widget child);
  public void removeWidget(Object key);
  public void enableWidget(Object key);
  public void disableWidget(Object key);
  ...
}</programlisting>
        As one can see, every added child has an identifier which should be unique among its siblings. This identifier is used when rendering and sending events to the widget in question, to identify it among its peers.
      </para>

      <para>
        Typically, children are added when created:
        <programlisting role="java">addWidget("myChildWidget", new MyChildWidget("String parameter", 1));</programlisting>
        An added child will be initialized, will receive updates and events and may be rendered. A widget can be active only if added to a parent. It will live as long as the parent, unless the parent explicitly removes it:
        <programlisting role="java">removeWidget("myChildWidget");</programlisting>
      Removing a child widget will destroy it and one should also dispose of any references that may be pointing to it, to allow the child to be garbage collected.
      </para>
      <para>
        A usual idiom is to save a reference to the newly created and added child using a parent widget field:
        <programlisting role="java">public class MyWidget extends BaseUIWidget {
  private MyChildWidget myChildWidget;
  
  protected void init() {
    myChildWidget = new MyWidget("String parameter", 1);
    addWidget("myChildWidget", myChildWidget);
  }
}</programlisting>
        This allows to call directly child widget methods and does not anyhow significantly increase memory usage, so this technique may be used everywhere when needed. 
      </para>
      
      <para>
        Disabling a child (<literal>disableWidget("myChildWidget")</literal>) will stop it from receiving any events or rendering, but will not destroy it. It can later be reenabled by calling <literal>enableWidget("myChildWidget")</literal>.
      </para>
    </sect2>

    <sect2>
      <title>Event listeners</title>

      <para>
        Registering event listeners allows widgets to subscribe to some specific user events (widget will receive only events specially sent to it). The distinction comes by the ``event identifier'' that is assigned to an event when sending it. The events are handled by the classes extending <literal>org.araneaframework.core.EventListener</literal>:
<programlisting role="java">public interface EventListener extends Serializable {
  public void processEvent(Object eventId, InputData input) throws Exception;
}</programlisting>
      The event listeners are registered as following:
<programlisting role="java">addEventListener("myEvent", new EventListener() {
  public void processEvent(Object eventId, InputData input) throws Exception {
    log.debug("Received event: " + eventId);
  }
}</programlisting>      
      Of course, the event listener does not have to be an anonymous class and can just as well be an inner or even a usual public class. 
      A standard base implementation <literal>org.araneaframework.core.StandardEventListener</literal> is provided that receives an optional <literal>String</literal> event parameter:
<programlisting role="java">addEventListener("myEvent", new StandardEventListener() {
  public void processEvent(Object eventId, String eventParam, InputData input) throws Exception;
    log.debug("Received event " + eventId + " with parameter " + parameter);
  }
}</programlisting>      
      </para>

      <para>
        Another useful way to process events is to register a proxy event listener (<literal>org.araneaframework.core.ProxyEventListener</literal>) that will proxy the event to a method call, e.g.:
<programlisting role="java">protected void init() {
  addEventListener("myEvent", new ProxyEventListener(this));
}

public void handleEventMyEvent(String parameter) {
    log.debug("Received event myEvent with parameter " + parameter);
}</programlisting>        
      The convention is that the proxy event listener translates an event "&lt;event&gt;" into a method call <literal>handleEvent&lt;event&gt;</literal> making the first letter of &lt;event&gt; uppercase. The <literal>String parameter</literal> is optional and can be omitted. 
      </para>

      <para>
        A useful feature is the method <literal>addGlobalEventListener(EventListener listener)</literal> that allows to register a listener that will receive all events sent to the widget. In fact <literal>BaseUIWidget</literal> does that by default, and typically you will use the individual event listeners only when you want to override this default behaviour. This allows to just define correct method names (<literal>handleEvent&lt;event&gt;</literal>) and all events will be translated to the calls to these methods. Certainly this can also be cancelled by calling <literal>clearGlobalEventListener()</literal>, or overridden by adding your own global event listener.

      </para>
    </sect2>
    <sect2 id="widgets-environment">
      <title>Environment</title>

      <para>
        Every initialized widget has a reference to <literal>org.araneaframework.Environment</literal> available through the <literal>getEnvironment()</literal> method. Environment allows to look up framework services (called <emphasis>contexts</emphasis>):
<programlisting role="java">MessageContext msgCtx = (MessageContext) getEnvironment().getEntry(MessageContext.class);
msgCtx.showInfoMessage("Hello world!");</programlisting>        
      As one can see from the examples, contexts are looked up using their interface <literal>Class</literal> object as key. All framework services in Aranea are accessible only using the environment.
      </para>      
    </sect2>
    <sect2>
      <title>Overridable Methods</title>
      <para>
        The main method that is typically overridden in a widget is <literal>init()</literal>. As widget does not get an environment before it is added and initialized it is impossible to access framework services in the constructor, therefore most of the initialization logic moves to the custom <literal>init()</literal> method. A dual overridable method is <literal>destroy()</literal>, though it is used much less. 
      </para>

      <para>
        In addition to event processing it is sometimes useful to do some kind of pre- and post-processing. The <literal>BaseApplicationWidget</literal> has the following methods that may be overridden to allow this processing:
<programlisting role="java">
  protected void handleUpdate(InputData input) throws Exception {}
  protected void handleProcess() throws Exception {}
</programlisting>        
      <literal>handleUpdate()</literal> is called before event listeners are notified and allows to read and save request data preparing it for the event. More importantly, this method is called even when no event is sent to the current widget allowing one to submit some data to any widget. <literal>handleProcess()</literal> is called after the event listeners are notified and again is called event if current widgets receives no events at all. It allows to prepare the widget for rendering, post-processing the request results without concern whether or not events have been delivered.
      </para>
    </sect2>
    <sect2>
      <title>InputData and OuputData</title>

      <para>
        In Aranea one usually  does not need to handle request manually in custom application widgets. Even more, the request is not accessible by default. The usual way to submit custom data to a widget and read it is using Aranea Forms (see <xref linkend="forms"/>). However, when one needs to access the submitted data, one can do that using the <literal>org.araneaframework.InputData</literal>. This class can be used as follows:
<programlisting role="java">...
String myData1 = 
  (String) getInputData().getScopedData().get("myData1");
String globalSubmittedParameter = 
  (String) getInputData().getGlobalData().get("globalSubmittedParameter");
...</programlisting>        
      <literal>getInputData()</literal> is a <literal>BaseApplicationWidget</literal> method that returns the input data for the current 
      request (one can also use  the <literal>inputData</literal> parameter given to event listener directly). <literal>getScopedData()</literal> 
      returns a <literal>java.util.Map</literal> with data submitted to the current widget specifically (typically this will mean that the data 
      was prefixed with the full widget id in request). <literal>getGlobalData()</literal> returns the data that was submitted globally (typically the
      data that was not prefixed anyhow in the request). 
      </para>

      <para>
        One can also obtain the <literal>HttpServletRequest</literal> from the 
        <literal>InputData</literal> by calling <literal>ServletUtil.getRequest(InputData data)</literal>.
      </para>

      <para>
        <literal>org.araneaframework.OutputData</literal> usually does not play any role in application development.
        It is accessible through the <literal>getOutputData()</literal> method of <literal>BaseWidget</literal>.
        <literal>HttpServletResponse</literal> can be accessed by calling <literal>ServletUtil.getResponse(OutputData data)</literal>.
        Additionally <literal>HttpOutputData</literal> also has a method <literal>sendRedirect(String location)</literal> which should be used as follows:
<programlisting role="java">...
((HttpOutputData) getOutputData()).sendRedirect("http://www.google.com");
...</programlisting>        
        This method does an HTTP redirect to the specified URL.
      </para>
    </sect2>
    <sect2>
      <title>View Model and Rendering</title>

      <para>
        <literal>BaseApplicationWidget</literal> also contains methods that facilitate transferring data to the presentation layer. This is achieved using a <emphasis>View model</emphasis>&mdash;an object containing a snapshot of the widget current state. The most typical way to use the view model it to add data to it:
<programlisting role="java">...
putViewData("today", new Date());
putViewData("currentUser", userBean);
...</programlisting>
      View data is typically accessible in the presentation layer as some kind of a variable (e.g. a JSP EL variable) for the current widget. If the data becomes outdated one can override it using <literal>putViewData()</literal> call or remove it using the <literal>removeViewData()</literal> call. In case one needs to put view data that would last one request only there is an alternative method:
<programlisting role="java">...
putViewDataOnce("now", new Date());
...</programlisting>
      </para>

      <para>
        <literal>BaseUIWidget</literal> allows to render the current widget using a JSP page. To do that one needs to select a view as follows:
<programlisting role="java">...
setViewSelector("myWidget/form");
...</programlisting>        
        This code makes the widget render itself using the JSP situated in <literal>WEB-INF/jsp/myWidget/form.jsp</literal> (of course the exact place is configurable). It is also possible to render the widget using other template technologies with the same view selector by overriding the <literal>render()</literal> method in the base project widget.
      </para>
    </sect2>
    <sect2 id="widgets-example-widget">
      <title>Putting It All Together</title>

      <para>
        A typical application custom widget will look like that:
<programlisting role="java">public class TestWidget extends BaseUIWidget {

  private static final Logger log = Logger.getLogger(TestWidget.class);
  
  private Data data;
  
  protected void init() throws Exception {
    //Sets the JSP for this widget to "/WEB-INF/jsp/home.jsp"
    setViewSelector("home");
    
    //Get data from the business layer
    data = ((TestService) lookupService("testService")).getData("test parameter");
    
    //Make the data accessible to the JSP for rendering
    putViewData("myData", data);    
  }
  
  /*
   * Event listener method that will process "test" event.
   */
  public void handleEventTest() throws Exception {
    getMessageCtx().showInfoMessage("Test event received successfully");       
  }
}</programlisting>
      </para>
    </sect2>
	</sect1>
  <sect1>
    <title>Standard Contexts</title>    

    <para>
      Contexts are the Aranea way to access framework services. They can be looked up from the environment as shown in <xref linkend="widgets-environment"/>. This section describes the most common Aranea contexts that should be available in any typical configuration. All these contexts are also available directly through <literal>BaseUIWidget</literal> methods as shown further on.
    </para>
    
    <sect2 id="MessageContext">
      <title>MessageContext</title>

      <para>
        <literal>org.araneaframework.framework.MessageContext</literal> allows to show messages to the user. The messages can be of several types, inluding predefined error and informative types. Typically messages will be shown somewhere in the application (exact way is application-specific). <literal>MessageContext</literal> is available through a <literal>BaseUIWidget</literal> method <literal>getMessageCtx()</literal> and is typically used as follows:
<programlisting role="java">getMessageCtx().showInfoMessage("Hello world!");</programlisting>        
      More info is available in the JavaDoc.
      </para>
    </sect2>
    
    <sect2 id="LocalizationContext">
      <title>LocalizationContext</title>

      <para>
        <literal>org.araneaframework.framework.LocalizationContext</literal> allows to get and set current session locale, localize strings and lookup resource bundles. The context is available through the <literal>BaseUIWidget</literal> method <literal>getL10nCtx()</literal>. Typically it is used as following:
<programlisting role="java">
...
String message = getL10nCtx().localize("my.message.key");
getMessageCtx().showInfoMessage(message);
...
</programlisting>
      More info is available in the JavaDoc.
      </para>
    </sect2>
    <sect2 id="FlowContext">
      <title>FlowContext</title>
      
      <para>
        A common need in a web programming is to support navigation style known as <emphasis>flows</emphasis>&mdash;interactive stateful processes that can navigate to each other passing arguments when needed. A more complex case is when we also have flow nesting&mdash;a flow can call a subflow, and wait for it to finish, then reactivate again. In this case we can have at any given moment a stack of flows, where the top one is active, and the next one will reactivate when the top one finishes. It is also useful if nested flows can return resulting values when they finish.
      </para>
      
      <para>
       <literal>org.araneaframework.framework.FlowContext</literal> is the Aranea context that provides support for nested flow navigation. Aranea flow is a widget that is running in the flow container (using the <literal>FlowContext.start()</literal> method. Aranea abstraction for the nested state is that of a function&mdash;the nested <emphasis>flow</emphasis> takes in some parameters and when finished may return some value or signal that no value can be returned. The context is available as <literal>getFlowCtx()</literal> method of <literal>BaseUIWidget</literal> and allows to start flows, finish flows and return the resulting value.
      </para>

      <para>
        To start a new flow one needs to create a widget as usual. The widget may take some parameters in the constructor&mdash;they are considered to be the incoming parameters of the flow:
<programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), null, null);
...</programlisting>        
        This call will start a new nested flow for the widget <literal>TestFlow</literal> making the current flow inactive. <literal>TestFlow</literal> will render and receive event until it explicitly returns control to the starting flow. Note that this code will start the flow and then return the control, so it is important not to do anything in the same method after starting a new flow. 
      </para>

      <para>
        To end the flow successfully one needs to do as follows:
<programlisting role="java">...
getFlowCtx().finish(new Long(8));
...</programlisting>        
        This call will finish the current flow (in our case <literal>TestFlow</literal>) and return the control to the starting flow and its widget. 
      </para>

      <para>
        Often one needs to handle the return from the flow, processing the returned result. This corresponds to our abstraction of a method, however since Java does not support continuations we chose to allow the caller to register a handler when starting the flow by passing a <literal>FlowContext.Handler</literal>:
<programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), null, 
  new FlowContext.Handler() {
    public void onFinish(Object result) {
      getMessageCtx().showInfoMessage("TestFlow returned value " + result);
    }
    public void onCancel() {
      //Ignore cancelled flow
    }
  });
...</programlisting>        
      </para>

      <para>
        A less common but nevertheless useful feature is to configure the starting flow after it has been initialized. For that the caller needs to pass a <literal>FlowContext.Configurator</literal>:
<programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), 
  new FlowContext.Configurator() {
     public void configure(Component comp) {
      ((TestFlow) comp).setStrategy(TestFlow.ATTACK);
     }
  }, null);
...</programlisting>        
      </para>

      <para>
        Finally <literal>FlowContext</literal> also allows to replace the current flow instead of deactivating it by using the <literal>replace()</literal> method and to cancel the current flow by using the <literal>cancel()</literal> method.
      </para>
      
      <para>
        For standard implementation, please see <xref linkend="StandardFlowContainerWidget"/>
      </para>
    </sect2>
  </sect1>
</chapter>
