<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2006 Webmedia Group Ltd.
 
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<chapter id="core">
  <title>Components, Widgets and Services</title>

  <sect1>
    <title>Introduction</title>

    <para>Aranea framework and component model are very simple and implemented
    purely in Plain Old Java. There are no XML mappings, code generation or
    bytecode enhancement. The whole component model consists mainly of five
    interfaces: <classname>org.araneaframework.Component</classname>,
    <classname>org.araneaframework.Service</classname>,
    <classname>org.araneaframework.Widget</classname>,
    <classname>org.araneaframework.Environment</classname>,
    <classname>org.araneaframework.Message</classname> and some conventions
    regarding their usage and implementation.</para>

    <para>This chapter describes the core Aranea abstractions in detail
    generally not necessary to just develop application code so it can be
    skipped during the first reading. It is quite dry on the examples, but its
    understanding is crucial to develop Aranea extensions.</para>
  </sect1>

  <sect1>
    <title>Coding Conventions</title>

    <sect2>
      <title>Checked versus Unchecked Exceptions</title>

      <para>It is our firm belief that checked exceptions are unnecessary in
      <emphasis>Controller</emphasis> and therefore Aranea will in most cases
      allow to just declare your overriding method as <literal>throws
      Exception</literal>. On the other hand no framework interfaces throw
      checked exceptions so the exception-handling boilerplate can be
      delegated to a single error-handling component.</para>
    </sect2>

    <sect2>
      <title>Public versus Framework Interfaces</title>

      <para>Since the application programmer implements the same components
      that are used for framework extension, it is important to discourage the
      access to public framework interfaces (which are necessarily visible in
      the overridden classes). Thus a simple convention is applied for core
      framework interfaces, which is best illustrated with the following
      example.</para>

      <programlisting role="java">public interface Service extends Component, Serializable {
  public Interface _getService();

  public interface Interface extends Serializable {
    public void action(Path path, InputData input, OutputData output) throws Exception;
  }
}</programlisting>

      <para>As one can see, the real interface methods are relocated to an
      inner interface named <classname>Interface</classname>, that can be
      accessed using a method
      <classname>_get&lt;InterfaceName&gt;()</classname>, which starts with an
      underscore to discourage its use. As a rule of a thumb, in Aranea the
      methods starting with an underscore should only be used, when one really
      knows what one is doing.</para>
    </sect2>

    <sect2>
      <title>Components and Their Orthogonal Properties</title>

      <para>Aranea has three main types of components:
      <classname>org.araneaframework.Component</classname>,
      <classname>org.araneaframework.Service</classname> and
      <classname>org.araneaframework.Widget</classname>. These components also
      have a number of orthogonal properties (like
      <classname>Viewable</classname>, <classname>Composite</classname>),
      which are represented by interfaces that need to be implemented. Since
      some particular API methods expect a particular type of component with a
      particular property (e.g. <classname>ViewableWidget</classname>) one
      would either have to abandon static type safety or define a lot of
      meaningless interfaces that would clutter the Javadoc index and confuse
      the source code readers. The approach chosen in Aranea is to make such
      interfaces internal to the property, like in the following
      example.</para>

      <programlisting role="java">public interface Viewable extends Serializable {
  public Interface _getViewable();

  interface Interface extends Serializable {
    public Object getViewModel() throws Exception;
  }

  public interface ViewableComponent extends Viewable, Component, Serializable {}
  public interface ViewableService extends ViewableComponent, Service, Serializable {}
  public interface ViewableWidget extends ViewableService, Widget, Serializable {}
}</programlisting>
    </sect2>
  </sect1>

  <sect1>
    <title>Components and Environment</title>

    <para><classname>org.araneaframework.Component</classname> represents the
    unit of encapsulation and reuse in Aranea. Components are used to both
    provide plug-ins and extensions to the framework and to implement the
    actual application-specific code. A component has (possibly persistent)
    state, life cycle, environment and a messaging mechanism. <programlisting
    role="java">public interface Component extends Serializable {
  public Component.Interface _getComponent();

  public interface Interface extends Serializable {
    public void init(Environment env) throws Exception;
    public void destroy() throws Exception;
    public void propagate(Message message) throws Exception;
    public void enable() throws Exception;
    public void disable() throws Exception;
  }
}</programlisting></para>

    <para>The component life cycle goes as follows: <orderedlist
        spacing="compact">
        <listitem>
           

          <function>init()</function>

          —notifies the component that it should initialize itself passing it the 

          <classname>Environment</classname>

           . A component can be initialized only once and the environment it is given stays with it until it is destroyed. 
        </listitem>

        <listitem>
           All other calls (like 

          <literal>propagate()</literal>

           ) should be done when a component is alive, initialized and enabled. 
        </listitem>

        <listitem>
           

          <function>disable()</function>

          —notifies the component that it will be disabled and will not receive any calls until it is enabled again. A component is enabled by default. 
        </listitem>

        <listitem>
           

          <function>enable()</function>

          —notifies the component that it has been enabled again. This call may only be done after a 

          <classname>disable()</classname>

           call. 
        </listitem>

        <listitem>
           

          <function>destroy()</function>

          —notifies the component that it has been destroyed and should release any acquired resources and such. A component can be destroyed only once and should be initialized before that. 
        </listitem>
      </orderedlist> Further in the text we will refer to an initialized and
    not destroyed component instance that has a parent as
    <emphasis>live</emphasis> and one that has not been disabled or has been
    re-enabled as <emphasis>enabled</emphasis>.</para>

    <para>Aranea provides a base implementation of the
    <literal>Component</literal> —
    <literal>org.araneaframework.core.BaseComponent</literal>. This
    implementation mainly enforces contracts (including life cycle and some
    basic synchronization). A base class for application development
    <literal>org.araneaframework.core.BaseApplicationComponent</literal> is
    also available.</para>

    <sect2>
      <title>Composite Pattern and Paths</title>

      <para><emphasis>Composite</emphasis> pattern refers to a design approach
      prominent (specifically) in the GUI modeling when objects implementing
      the same interface are arranged in a hierarchy by containment, where the
      nodes of the tree propagate calls in some way to the leafs of the tree.
      It is shown on <xref linkend="composite-pattern" />.</para>

      <figure id="composite-pattern">
        <title><emphasis>Composite</emphasis> design pattern</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/composite.png" format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><emphasis>Composite</emphasis> is one of the main patterns used in
      Aranea. It is mainly used to create a <emphasis>Hierarchical
      Controller</emphasis> using <literal>Component</literal> containment. In
      terms of <literal>Component</literal> interface
      <emphasis>Composite</emphasis> is used to propagate life cycle events
      and route messages (see <xref linkend="components-messaging" />).</para>

      <para>The flavor of the <emphasis>Composite</emphasis> pattern as used
      in Aranea typically means that every contained component has some kind
      of an identifier or name that distinguishes it from other children of
      the same parent (note that the child is not typically aware of its
      identifier). This identifiers are used to route messages and events and
      can be combined to form a full identifier which describes a "path" from
      the root component to the child in question. This paths are represented
      by a <emphasis>Iterator</emphasis>-like interface
      <literal>org.araneaframework.Path</literal>. <programlisting
      role="java">public interface Path extends Cloneable, Serializable {
  public Object getNext();
  public Object next();
  public boolean hasNext();
}</programlisting></para>

      <para>Each <literal>next()</literal> call will return the identifier of
      the next child in the path to the descendant in question. Default
      implementation
      (<literal>org.araneaframework.core.StandardPath</literal>) uses simple
      string identifiers like "a" or "b" and combines them using dots forming
      full paths like "a.b.c".</para>

      <para>A <emphasis>Composite</emphasis> component may want to make its
      children visible to the outside world by implementing the
      <literal>org.araneaframework.Composite</literal> interface:
      <programlisting role="java">public interface Composite extends Serializable {
  public Composite.Interface _getComposite();
  public interface Interface extends Serializable {
    public Map getChildren();
    public void attach(Object key, Component comp);
    public Component detach(Object key); 
  }
}</programlisting></para>

      <para>This interface allows to both inspect and manipulate component
      children by attaching and detaching them from the parent
      component.</para>

      <para>As most of the Aranea abstractions are built to be used with the
      <emphasis>Composite</emphasis> concept we will illustrate it in greater
      detail when examining other abstractions and their implementation.
      Further on we will assume that any <literal>Component</literal> has a
      parent that contains it and every child has some kind of name in
      relation to the parent unless noted otherwise (obviously there is at
      least one <emphasis>Composite</emphasis> that does not have a parent,
      but we don't really care about that at the moment).</para>
    </sect2>

    <sect2>
      <title>Environment</title>

      <para><literal>org.araneaframework.Environment</literal> is another
      important concept that represents the way <literal>Component</literal>s
      interact with the framework. <literal>Environment</literal> interface is
      rather simple: <programlisting role="java">public interface Environment extends Serializable {
  public Object getEntry(Object key);
}</programlisting></para>

      <para>It basically provides means of looking up entry objects by their
      key. A typical usage of the <literal>Environment</literal> can be
      illustrated with an example. <programlisting role="java">...
MessageContext msgCtx = (MessageContext) getEnvironment().getEntry(MessageContext.class);
msgContext.showInfoMessage("Hello world!");
...</programlisting></para>

      <para>As one can see from the example <literal>Environment</literal>
      will typically allow to look up implementations of the interfaces using
      their <literal>Class</literal> as the key (this is in fact an Aranea
      convention in using and extending the <literal>Environment</literal>).
      The interfaces serving as keys for <literal>Environment</literal>
      entries are referred to as <emphasis>contexts</emphasis>. It is thus not
      unlike JNDI or some other directory lookups that allow to hold objects,
      however unlike them <literal>Environment</literal> is very specific to
      the <literal>Component</literal> it is given to, and can be influenced
      by its parents. In fact, all contexts available in the
      <literal>Environment</literal> will be provided to the
      <literal>Component</literal> by its parents or ancestors (in the sense
      of containment rather than inheritance). Thus, two different
      <literal>Component</literal>s may have completely different
      <literal>Environment</literal>s.</para>

      <para>A default implementation of <literal>Environment</literal> is
      <literal>org.araneaframework.core.StandardEnvironment</literal>. It
      provides for creating an <literal>Environment</literal> from a
      <literal>java.util.Map</literal>, or extending an existing environment
      with map entries.</para>

      <para>A component can provide an environment entry to its descendant, by
      providing it to the initializer of its direct child. For instance the
      <literal>MessageContext</literal> could be provided by the following
      message component:</para>

      <para><programlisting role="java">public class MessageFilterService implements MessageContext, Component, Service {
  protected Service childService;
  public void setChildService(Service childService) {
    this.childService = childService;
  }

  public void init(Environment env) {
    childService.init(
      new StandardEnvironment(env, MessageContext.class, this);
  }

  //MessageContext implementation...
  public String showInfoMessage(String message) {
    //Show message to user...
  }  

  //...
}
</programlisting></para>

      <para>After that the <literal>childService</literal>, its children and
      so on will be able to use the <literal>MessageContext</literal> provided
      by <literal>MessageFilterService</literal>. Of course this can be done
      simpler as shown in examples in chapter</para>
    </sect2>

    <sect2 id="components-messaging">
       

      <title>Messaging Components</title>

       

      <para>So far, we have looked at the component management and
      environment. However what makes the component hierarchy such a powerful
      concept is messaging. Basically, messaging allows us to send any events
      to any component in the hierarchy (including all components or a
      specific one). The messaging is incorporated using the
      <literal>org.araneaframework.Message</literal> interface <programlisting
      role="java">public interface Message extends Serializable {
  public void send(Object id, Component component) throws Exception;
}</programlisting> and <literal>Component.propagate(Message message)</literal>
      method. The default behavior of the <literal>propagate()</literal>
      method should be to send the message to all component children, passing
      the <literal>send()</literal> method the identifier of the child and the
      child itself. It is up to the message what to do with the child further,
      but typically some form of <emphasis>double-dispatch</emphasis> takes
      place and message propagates itself further.</para>

       TODO: explain double-dispatch 

      <para>A standard <literal>Message</literal> implementation that uses
      double-dispatch to visit all the components in hierarchy is
      <literal>org.araneaframework.core.BroadcastMessage</literal>. It usage
      can be illustrated with the following example: <programlisting
      role="java">...
Message myEvent = new BroadcastMessage() {
  public void execute(Component component) throws Exception {
  if (component instanceof MyEventListener)
    ((MyEventListener) component).onMyEvent(data);
  }
}
myEvent.send(null, rootComponent);
...</programlisting> This code will call all the components in the hierarchy
      that subscribed to the event and pass them a certain
      <literal>data</literal> parameter. As one can see, when calling
      <literal>Message.send()</literal> we will typically pass
      <literal>null</literal> as the first parameter, since it is needed only
      when propagating messages further down the hierarchy. Note that messages
      can be used to gather data from the components just as well as for
      passing data to them. For example one could construct message that
      gathers all <literal>FormWidget</literal>s from the widget
      hierarchy:</para>

      

      <para>
        <programlisting role="java">public static class FormWidgetFinderMessage extends BroadcastMessage {
  List formList = new ArrayList();

  protected void execute(Component component) throws Exception {
    if (component instanceof org.araneaframework.uilib.form.FormWidget) {
      formList.add(component);
    }
  }

  public List getAllForms() { return formList; }
}</programlisting>
      </para>

       

      <para>Another standard <literal>Message</literal> implementation is
      <literal>org.araneaframework.core.RoutedMessage</literal>, which allows
      us to send a message to one specific component in the hierarchy as in
      the following example: <programlisting role="java">...
Message myEvent = new RoutedMessage("a.b.c") {
  public void execute(Component component) throws Exception {
    ((MyPersonalComponent) component).myMethod(...);
  }
}
myEvent.send(null, rootComponent);
...</programlisting> This code will send the message to the specific component
      with path "a.b.c" and call <literal>myMethod()</literal> on it.</para>

       
    </sect2>

    <sect2 id="components-persistence">
      <title>State and Synchronization</title>

      <para>The handling of persistent state in Aranea is very simple. There
      are no scopes and every component state is saved until it is explicitly
      removed by its parent. This does not mean that all of the components are
      bound to the session, but rather that most components will live a period
      of time appropriate for them (e.g. framework components will live as
      long as the application lives, GUI components will live until user
      leaves them, and so on). This provides for a very flexible approach to
      persistence allowing not to clutter memory with unused
      components.</para>

      <para>The end result is that typically one needs not worry about
      persistence at all, unless one is programming some framework plug-ins.
      All class fields (except in some cases <literal>transient</literal>
      fields) can be assumed to persist while the host object is
      <emphasis>live</emphasis>.</para>

      <para>However such handling does not guarantee that the component state
      is anyhow synchronized. As a matter of fact most of the framework
      components outside the user session should be able to process concurrent
      calls and should take care of the synchronization themselves. However
      application components are typically synchronized by the framework. More
      information on the matter will follow in <xref
      linkend="programming-with-widgets" />.</para>
    </sect2>
  </sect1>

  <sect1 id="components-io-data">
    <title>InputData and OutputData</title>

    <para><literal>InputData</literal> is Aranea abstraction for a request,
    which hides away the Servlet API and allows us to run Aranea on different
    containers (e.g. in a portlet or behind a web service).</para>

    <para>Both <literal>InputData</literal> and <literal>OutputData</literal>
    have a <emphasis>scope</emphasis>, which is information about the path to
    the current component. When they are propagated through the component
    hierarchy the following methods are used to construct the scope:</para>

    <para><informaltable frame="topbot">
        <tgroup cols="2">
          <colspec colwidth="1*" />

          <colspec colwidth="2*" />

          <thead>
            <row>
              <entry align="left">Method</entry>

              <entry align="left">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>pushScope(Object step)</literal></entry>

              <entry>Adds child identifier to the end of the current scope,
              should <emphasis>always</emphasis> be used before the call to
              the child.</entry>
            </row>

            <row>
              <entry><literal>Object popScope()</literal></entry>

              <entry>Removes the last identifier from the scope, should
              <emphasis>always</emphasis> be used a call to a child.</entry>
            </row>

            <row>
              <entry><literal>Path getScope()</literal></entry>

              <entry>Returns the current scope as a
              <literal>Path.</literal></entry>
            </row>

            <row>
              <entry><literal>restoreScope(Path scope)</literal></entry>

              <entry>Restore the scope back to a previously saved one.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <note>
      <para>These methods should be used only when using
      <emphasis>Composite</emphasis> components, as framework components are
      scoped differently.<literal></literal></para>
    </note>

    <para><literal>InputData</literal> also provides access to the data sent
    to the component. This data comes in two flavours: <itemizedlist
        spacing="compact">
        <listitem>
          <literal>getScopedData()</literal>

           returns a 

          <literal>java.util.Map</literal>

           with the data sent specially to this component, which is associated with the current scope.
        </listitem>

        <listitem>
          <literal>getGlobalData()</literal>

           returns a 

          <literal>java.util.Map</literal>

           with the data sent to the application generally.
        </listitem>
      </itemizedlist> In case Aranea is running on top of a servlet both these
    maps will contain only <literal>String</literal>s (or in case you
    submitted more than one value for a specific key it may contain a
    <literal>String[]</literal>). In case of the usual path and scope
    implementation (as dot-separated strings) <emphasis>global data</emphasis>
    will contain the submitted parameters with no dots in them and
    <emphasis>scoped data</emphasis> will contain the parameters prefixed with
    the current component scope string.</para>

    <para>The main function of <literal>OutputData</literal> is to propagate
    attributes that are used when delegating rendering to a templating engine
    or by children to access some general information during rendering. The
    following methods are used to propagate these attributes: </para>

    <informaltable frame="topbot">
      <tgroup cols="2">
        <colspec colwidth="1*" />

        <colspec colwidth="2*" />

        <thead>
          <row>
            <entry align="left">Method</entry>

            <entry align="left">Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><literal>pushAttribute(Object key, Object
            value)</literal></entry>

            <entry>Registers the attribute <literal>value</literal> under the
            key <literal>key</literal>. If some other component have already
            propagated an attribute under this key, then it will be temporary
            overridden.</entry>
          </row>

          <row>
            <entry><literal>Object popAttribute(Object key)</literal></entry>

            <entry>Deregisters the attribute from under the key
            <literal>key</literal>. If the attribute was temporary overridden
            it will restore the previous attribute value.</entry>
          </row>

          <row>
            <entry><literal>Object getAttribute(Object key)</literal></entry>

            <entry>Returns the last object registered under key
            <literal>key</literal>.</entry>
          </row>

          <row>
            <entry><literal>Map getAttributes()</literal></entry>

            <entry>Returns all currently registered attributes.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Finally, as <literal>InputData</literal> and
    <literal>OutputData</literal> are typically connected, they can be
    retrieved from the other <literal>*Data</literal> structure using
    correspondingly <literal>getOutputData()</literal> and
    <literal>getInputData()</literal> methods. </para>

    <warning>
      <para>Since the the sibling <literal>*Data</literal> structure is not
      propagated through the component hierarchy is not guaranteed to be
      scoped correctly!</para>
    </warning>

    <sect2>
      <title>Extensions</title>

      <para>InputData an Outputdata both implement a way to extend their
      functionality without wrapping or extending the objects themselves. This
      is achieved by providing the following two methods:</para>

      <para><programlisting role="java">void extend(Class interfaceClass, Object extension)
Object narrow(Class interfaceClass);</programlisting></para>

      <para>The following example should give an idea of applying these
      methods:</para>

      <para><programlisting role="java">input.extend(FileUploadExtension.class, new FileUploadExtension(input));

...

FileUploadExtension fileUploadExt = 
  (FileUploadExtension) input.narrow(FileUploadExtension.class);
if (fileUploadExt.uploadSucceeded()) {
  //...
}</programlisting></para>

      <note>
        <para>Both <literal>HttpServletRequest</literal> and
        <literal>HttpServletResponse</literal> are available as
        <literal>InputData</literal> and <literal>OutputData</literal>
        extensions respectively.</para>
      </note>
    </sect2>

    <sect2>
      <title>HttpInputData and HttpOutputData</title>

      <para>Although all of the core Aranea abstractions are independent of
      the Servlet API and web in general, we also provide a way to manipulate
      low-level HTTP constructs. To that goal we provide to interfaces,
      <literal>HttpInputData</literal> and <literal>HttpOutputData</literal>,
      which extend respectively <literal>InputData</literal> and
      <literal>OutputData</literal>.</para>

      <para>Let's examine the <literal>HttpInputData</literal>. First of all
      it provides methods that are similar to the ones found in the
      <literal>HttpServletRequest</literal>:</para>

      <para><informaltable frame="topbot">
          <tgroup cols="2">
            <colspec colwidth="1*" />

            <colspec colwidth="2*" />

            <thead>
              <row>
                <entry align="left">Method</entry>

                <entry align="left">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>Iterator getParameterNames()</literal></entry>

                <entry>Returns an iterator over names of the parameters
                submitted with the current request.</entry>
              </row>

              <row>
                <entry><literal>String[] getParameterValues(String
                name)</literal></entry>

                <entry>Returns the array of values of the particular parameter
                submitted with the current request.</entry>
              </row>

              <row>
                <entry><literal>String
                getCharacterEncoding()</literal></entry>

                <entry>Returns the character encoding that is used to decode
                the request parameters.</entry>
              </row>

              <row>
                <entry><literal>setCharacterEncoding(String
                encoding)</literal></entry>

                <entry>Sets the character encoding that is used to decode the
                request parameters. Note that this must be called before any
                parameters are read according to the Servlet
                specification.</entry>
              </row>

              <row>
                <entry><literal>String getContentType()</literal></entry>

                <entry>Returns the MIME content type of the request body or
                <literal>null</literal> if the body is lacking.</entry>
              </row>

              <row>
                <entry><literal>Locale getLocale()</literal></entry>

                <entry>Returns the preferred Locale that the client will
                accept content in, based on the Accept-Language header. If the
                client request doesn't provide an Accept-Language header, this
                method returns the default locale for the server.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <note>
        <para>Unlike <literal>InputData</literal> methods the parameters are
        presented as is and include both global and scoped parameters (the
        scoped ones are prefixed by the full name of the enclosing
        widget).</para>
      </note>

      <para>However next methods are a bit different from the
      <literal>HttpServletRequest</literal> alternatives:</para>

      <para><informaltable frame="topbot">
          <tgroup cols="2">
            <colspec colwidth="1*" />

            <colspec colwidth="2*" />

            <thead>
              <row>
                <entry align="left">Method</entry>

                <entry align="left">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>String getRequestURL()</literal></entry>

                <entry>Returns the target URL of the current request.</entry>
              </row>

              <row>
                <entry><literal>String getContainerURL()</literal></entry>

                <entry>Returns an URL pointing to the Aranea container (in
                most cases the dispatcher servlet).</entry>
              </row>

              <row>
                <entry><literal>String getContextURL()</literal></entry>

                <entry>Returns an URL pointing to the Aranea container context
                (in most cases the web application root).</entry>
              </row>

              <row>
                <entry><literal>String getPath()</literal></entry>

                <entry>Returns the path on the server starting from the
                dispatcher servlet that has been submitted as the part of the
                request target URL.</entry>
              </row>

              <row>
                <entry><literal>pushPathPrefix(String
                pathPrefix)</literal></entry>

                <entry>Consumes the path prefix allowing children to be mapped
                to a relative path.</entry>
              </row>

              <row>
                <entry><literal>popPathPrefix()</literal></entry>

                <entry>Restores the previously consumed path prefix.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>

      <para>The interesting part here are the methods that deal with the path.
      The problem is that unlike most common cases Aranea components form a
      hierarchy. Therefore if a parent is mapped to path prefix "myPath/*" and
      its child is mapped to a path prefix "myChildPath/*" if the path
      handling were absolute the child would never get the mapped calles. This
      is due to the child being really mapped to the path
      "myPath/myChildPath". Therefore the parent must consume the prefix
      "myPath/" using method <literal>pushPathPrefix()</literal> and then the
      child will be correctly matched to the relative path
      "myChildPath".</para>

      <para><literal>HttpOutputData</literal> contains methods that are
      comparable to the ones found in
      <literal>HttpServletResponse</literal>:</para>

      <para><informaltable frame="topbot">
          <tgroup cols="2">
            <colspec colwidth="1*" />

            <colspec colwidth="2*" />

            <thead>
              <row>
                <entry align="left">Method</entry>

                <entry align="left">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>String encodeURL(String url)</literal></entry>

                <entry>Encodes the URL to include some additional information
                (e.g. HTTP session identifier). Note that Aranea may include
                some information not present in the servlet spec.</entry>
              </row>

              <row>
                <entry><literal>sendRedirect(String
                location)</literal></entry>

                <entry>Sends an HTTP redirect to a specified location
                URL.</entry>
              </row>

              <row>
                <entry><literal>OutputStream
                getOutputStream()</literal></entry>

                <entry>Returns an <literal>OutputStream</literal> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</entry>
              </row>

              <row>
                <entry><literal>PrintWriter getWriter()</literal></entry>

                <entry>Returns a <literal>PrintWriter</literal> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</entry>
              </row>

              <row>
                <entry><literal>setContentType(String type)</literal></entry>

                <entry>Sets the MIME content type of the output. May include
                the charset, e.g. "text/html; charset=UTF-8".</entry>
              </row>

              <row>
                <entry><literal>Locale getLocale()</literal></entry>

                <entry>Returns the locale associated with the
                response.</entry>
              </row>

              <row>
                <entry><literal>String
                getCharacterEncoding()</literal></entry>

                <entry>Returns the character encoding used to write out the
                response.</entry>
              </row>

              <row>
                <entry><literal>void setCharacterEncoding(String
                encoding)</literal></entry>

                <entry>Sets the character encoding used to write out the
                response.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Services</title>

    <para><literal>org.araneaframework.Service</literal> is a basic
    abstraction over an event-driven <emphasis>Controller</emphasis> pattern
    that inherits life cycle, environment and messaging from the
    <literal>Component</literal>. The difference from the
    <literal>Component</literal> is as follows: <programlisting role="java">public interface Service extends Component, Serializable {
  public Interface _getService();

  public interface Interface extends Serializable {
    public void action(Path path, InputData input, OutputData output) throws Exception;
  }
}</programlisting></para>

    <para>The method <literal>action()</literal> is similar to the
    <literal>service()</literal> method in the Servlet API,
    <literal>InputData</literal> being an abstraction over a request and
    <literal>OutputData</literal> being an abstraction over a response (see
    <xref linkend="components-io-data" />). Thus a service will both process
    the request parameters and render itself during this method call. However
    unlike servlets services can be <emphasis>Composite</emphasis> and may be
    defined both statically (on application startup) or dynamically
    (adding/removing new services on the fly).</para>

    <para>Services are the basic working horses of the Aranea framework. They
    can generally be both synchronized and unsynchronized depending on the
    context. Services may also have persistent state and their lifetime is
    explicitly managed by their parent (see <xref
    linkend="components-persistence" />). The service life cycle is very
    simple—as long as the service is live and enabled it can receive
    <literal>action()</literal> calls, possibly several at a time.</para>

    <para>Aranea provides a base implementation of the
    <literal>Service</literal> —
    <literal>org.araneaframework.core.BaseService</literal> and a base class
    for application development
    <literal>org.araneaframework.core.BaseApplicationService</literal>.</para>

    <sect2 id="services-as-framework-plugins">
      <title>Services as Framework Plug-ins</title>

      <para>Services make up most of the actual Aranea framework. Even though
      they are simple, they can implement the following patterns:
      <variablelist>
          <varlistentry>
            <term>Filter</term>

            <listitem>
               Filter service is the simplest. It contains a single unnamed child service and implements the 

              <emphasis>Filter</emphasis>

               pattern by either passing the call to the child or not. However in addition to that it may enrich the child environment with contexts and provide more functionality like exception handling or synchronization. Typical examples of filter services are localization service (provides a localization context), synchronization service (synchronizes on 

              <literal>action()</literal>

               method) and transactional service that does not let through double submits. 
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Router</term>

            <listitem>
               Router service typically contains many named child services, and chooses only one to propagate the 

              <literal>action()</literal>

               call according to some 

              <literal>InputData</literal>

               parameter. Router service may have the child services statically preconfigured or it may create them dynamically when the request comes (the latter is the case with session service router). It may also allow us to add/remove children while the application is running. A typical application of a router is to distinguish among major application parts by some attribute (like component corresponding to a user session, or one of the popup window of current user). 
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Container</term>

            <listitem>
               Container services can have one or many children, but they typically will do more with them than just calling 

              <literal>action()</literal>

               on one of them. A typical example is the 

              <emphasis>widget container</emphasis>

               service which translates 

              <literal>action()</literal>

               calls into widget request-response cycle calls. 
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>Moe information on services and other components that make up the
      framework can be found in <xref linkend="framework" />.</para>
    </sect2>
  </sect1>

  <sect1 id="components-widgets">
    <title id="core-widgets">Widgets</title>

    <para><emphasis>Widget</emphasis> is the main abstraction used to program
    applications in Aranea. Widget is specifically any class extending the
    <literal>org.araneaframework.Widget</literal> interface and adhering to a
    number of conventions. More generally, widgets are components that
    function both as controllers and GUI elements, and that have the following
    properties: <variablelist>
        <varlistentry>
          <term>Synchronized</term>

          <listitem>
             The widget is always accessed by a single thread, therefore there is never any need to think about synchronization. One can assume that there is only one user using the application and program to service this user without any concern for concurrency. 
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Stateful</term>

          <listitem>
             When programming widgets there is no need to concern oneself with juggling the 

            <literal>HttpSession</literal>

             attributes or similar low-level mechanics. Widget state (meaning the class fields) is guaranteed to be preserved as long as the widget is alive. One can just use these fields to save the necessary data without any external state management, thus adhering to the rules of object-oriented encapsulation, . 
          </listitem>
        </varlistentry>
      </variablelist>The latter two properties make widgets ideal for
    programming custom application components.</para>

    <para>Widgets extend services with a request-response cycle:
    <programlisting role="java">public interface Widget extends Service, Serializable {
  public Interface _getWidget();
  
  public interface Interface extends Serializable {
    public void update(InputData data) throws Exception;
    public void event(Path path, InputData input) throws Exception;
    public void process() throws Exception;
    public void render(OutputData output) throws Exception;
  } 
}</programlisting></para>

    <para>Although widgets extend services, a widget will function during one
    request either as a widget or as a service—that is if a widget receives an
    <literal>action()</literal> call no other request-response cycle calls can
    occur.</para>

    <para>The widget request-response cycle proceeds as follows: <orderedlist
        spacing="compact">
        <listitem>
           

          <literal>update()</literal>

          —this method is called for all the widgets in the hierarchy. It allows widgets to read the data from request and possibly store some conversation state or at least temporary information to render the next view. 
        </listitem>

        <listitem>
           

          <literal>event()</literal>

          —this method is called on only one widget in the hierarchy. It allows to send widgets events from the user. The 

          <literal>path</literal>

           is used to route the event to the correct widget and is empty when the event is delivered to its endpoint. This method is optional in the widget request-response cycle. 
        </listitem>

        <listitem>
           

          <literal>process()</literal>

          —this method is called on all the widgets in the hierarchy. It allows widgets to process the result of 

          <literal>event()</literal>

           and 

          <literal>update()</literal>

           calls before rendering. 
        </listitem>

        <listitem>
           

          <literal>render()</literal>

          —the way this method is called depends on how widgets are rendered (see 

          <xref linkend="components-render" />

           ). It may be called only after 

          <literal>process()</literal>

           and may be called more than once (or not at all) during one request-response cycle. 
        </listitem>
      </orderedlist></para>

    <para>Aranea provides a base implementation of the
    <literal>Widget</literal>—<literal>org.araneaframework.core.Base</literal>Widget
    and a base class for application development
    <literal>org.araneaframework.core.BaseApplicationWidget</literal>. More on
    the last one can be found in <xref
    linkend="programming-with-widgets" />.</para>

    <sect2 id="components-render">
      <title>ViewModel and Rendering</title>

      <para>The default model of both widget and service rendering is that
      they render themselves. However, in most cases the widget might want to
      delegate the rendering to some templating language. In some other cases
      the widget might be rendered externally, without calling
      <literal>render()</literal> at all. Further on, we will describe these
      three cases in detail. <variablelist>
          <varlistentry>
            <term>Self-rendering</term>

            <listitem>
               In the most basic situation the widget will just use 

              <literal>OutputData</literal>

               for rendering by casting it into e.g. 

              <literal>ServletOutputData</literal>

               . In such a case the widget will just write out markup and return from the 

              <literal>render()</literal>

               method optionally rendering children as well. The data for rendering will be drawn from the widget fields as well as (possibly) 

              <literal>OutputData</literal>

               attributes. 
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Using templates for rendering</term>

            <listitem>
               The most common case in application widgets is to delegate rendering to a templating language. A widget may basically choose to render itself in arbitrary templating language as Aranea does not impose any restrictions. In fact, one widget may be rendered with one templating language, while another one with a completely different language. The template can gain access to the widget using the knowledge of the widget's full name (which is gathered in the 

              <literal>OutputData</literal>

               scope). It is then possible to acquire the widget View Model, which is a read-only representation of the widget state. For that the widget should implement 

              <literal>org.araneaframework.Viewable</literal>

               : 

              <programlisting role="java">public interface Viewable extends Serializable {
  public Interface _getViewable();

  interface Interface extends Serializable {
    public Object getViewModel() throws Exception;
  }  
}</programlisting>

               View model is put together by the widget being rendered and should contain all the data necessary to render the widget. 
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>External rendering</term>

            <listitem>
              <para>Finally, a widget <literal>render()</literal> method may
              not be called altogether and a <literal>Viewable</literal>
              widget may be rendered externally using the available View
              Model. This is the case with some reusable widgets which are
              rendered using e.g. JSP tags.</para>
            </listitem>
          </varlistentry>
        </variablelist></para>
    </sect2>

    <sect2>
      <title>Application Widgets</title>

      <para>A typical widget class will extend
      <literal>org.araneaframework.uilib.core.BaseUIWidget</literal>. This
      widget represents the usual custom application component that is
      rendered using Aranea custom JSP tags. <literal>BaseUIWidget</literal>
      inherits most of its functionality from
      <literal>org.araneaframework.core.BaseApplicationWidget</literal> the
      difference between the two being only that
      <literal>BaseUIWidget</literal> assumes to be connected with a JSP
      page.</para>

      <sect3>
        <title>Children management</title>

        <para><literal>BaseApplicationWidget</literal> provides a number of
        methods for managing child widgets:</para>

        <para><programlisting role="java">public abstract class BaseApplicationWidget ... {
  ...
  public void addWidget(Object key, Widget child);
  public void removeWidget(Object key);
  public void enableWidget(Object key);
  public void disableWidget(Object key);
  ...
}</programlisting></para>

        <para>As one can see, every added child has an identifier which should
        be unique among its siblings. This identifier is used when rendering
        and sending events to the widget in question, to identify it among its
        peers.</para>

        <para>Typically, children are added when created:</para>

        <para><programlisting role="java">addWidget("myChildWidget", new MyChildWidget("String parameter", 1));</programlisting></para>

        <para>An added child will be initialized, will receive updates and
        events and may be rendered. A widget can be active only if added to a
        parent. It will live as long as the parent, unless the parent
        explicitly removes it:</para>

        <para><programlisting role="java">removeWidget("myChildWidget");</programlisting></para>

        <para>Removing a child widget will destroy it and one should also
        dispose of any references that may be pointing to it, to allow the
        child to be garbage collected.</para>

        <para>A usual idiom is to save a reference to the newly created and
        added child using a parent widget field:</para>

        <para><programlisting role="java">public class MyWidget extends BaseUIWidget {
  private MyChildWidget myChildWidget;
  
  protected void init() {
    myChildWidget = new MyWidget("String parameter", 1);
    addWidget("myChildWidget", myChildWidget);
  }
}</programlisting></para>

        <para>This allows to call directly child widget methods and does not
        anyhow significantly increase memory usage, so this technique may be
        used everywhere when needed.</para>

        <para>Disabling a child
        (<literal>disableWidget("myChildWidget")</literal>) will stop it from
        receiving any events or rendering, but will not destroy it. It can
        later be reenabled by calling
        <literal>enableWidget("myChildWidget")</literal>.</para>
      </sect3>

      <sect3>
        <title>Event listeners</title>

        <para>Registering event listeners allows widgets to subscribe to some
        specific user events (widget will receive only events specially sent
        to it). The distinction comes by the ``event identifier'' that is
        assigned to an event when sending it. The events are handled by the
        classes extending
        <literal>org.araneaframework.core.EventListener</literal>:</para>

        <para><programlisting role="java">public interface EventListener extends Serializable {
  public void processEvent(Object eventId, InputData input) throws Exception;
}</programlisting></para>

        <para>The event listeners are registered as following:</para>

        <para><programlisting role="java">addEventListener("myEvent", new EventListener() {
  public void processEvent(Object eventId, InputData input) throws Exception {
    log.debug("Received event: " + eventId);
  }
}</programlisting></para>

        <para>Of course, the event listener does not have to be an anonymous
        class and can just as well be an inner or even a usual public class. A
        standard base implementation
        <literal>org.araneaframework.core.StandardEventListener</literal> is
        provided that receives an optional <literal>String</literal> event
        parameter:</para>

        <para><programlisting role="java">addEventListener("myEvent", new StandardEventListener() {
  public void processEvent(Object eventId, String eventParam, InputData input) throws Exception;
    log.debug("Received event " + eventId + " with parameter " + parameter);
  }
}</programlisting></para>

        <para>Another useful way to process events is to register a proxy
        event listener
        (<literal>org.araneaframework.core.ProxyEventListener</literal>) that
        will proxy the event to a method call, e.g.:</para>

        <para><programlisting role="java">protected void init() {
  addEventListener("myEvent", new ProxyEventListener(this));
}

public void handleEventMyEvent(String parameter) {
    log.debug("Received event myEvent with parameter " + parameter);
}</programlisting></para>

        <para>The convention is that the proxy event listener translates an
        event "&lt;event&gt;" into a method call
        <literal>handleEvent&lt;event&gt;</literal> making the first letter of
        &lt;event&gt; uppercase. The <literal>String parameter</literal> is
        optional and can be omitted.</para>

        <para>A useful feature is the method
        <literal>addGlobalEventListener(EventListener listener)</literal> that
        allows to register a listener that will receive all events sent to the
        widget. In fact <literal>BaseUIWidget</literal> does that by default,
        and typically you will use the individual event listeners only when
        you want to override this default behaviour. This allows to just
        define correct method names
        (<literal>handleEvent&lt;event&gt;</literal>) and all events will be
        translated to the calls to these methods. Certainly this can also be
        cancelled by calling <literal>clearGlobalEventListener()</literal>, or
        overridden by adding your own global event listener.</para>
      </sect3>

      <sect3 id="widgets-environment">
        <title>Environment</title>

        <para>Every initialized widget has a reference to
        <literal>org.araneaframework.Environment</literal> available through
        the <literal>getEnvironment()</literal> method. Environment allows to
        look up framework services (called
        <emphasis>contexts</emphasis>):</para>

        <para><programlisting role="java">MessageContext msgCtx = (MessageContext) getEnvironment().getEntry(MessageContext.class);
msgCtx.showInfoMessage("Hello world!");</programlisting></para>

        <para>As one can see from the examples, contexts are looked up using
        their interface <literal>Class</literal> object as key. All framework
        services in Aranea are accessible only using the environment.</para>
      </sect3>

      <sect3>
        <title>Overridable Methods</title>

        <para>The main method that is typically overridden in a widget is
        <literal>init()</literal>. As widget does not get an environment
        before it is added and initialized it is impossible to access
        framework services in the constructor, therefore most of the
        initialization logic moves to the custom <literal>init()</literal>
        method. A dual overridable method is <literal>destroy()</literal>,
        though it is used much less.</para>

        <para>In addition to event processing it is sometimes useful to do
        some kind of pre- and post-processing. The
        <literal>BaseApplicationWidget</literal> has the following methods
        that may be overridden to allow this processing:</para>

        <para><programlisting role="java">protected void handleUpdate(InputData input) throws Exception {}
protected void handleProcess() throws Exception {}
</programlisting></para>

        <para><literal>handleUpdate()</literal> is called before event
        listeners are notified and allows to read and save request data
        preparing it for the event. More importantly, this method is called
        even when no event is sent to the current widget allowing one to
        submit some data to any widget. <literal>handleProcess()</literal> is
        called after the event listeners are notified and again is called
        event if current widgets receives no events at all. It allows to
        prepare the widget for rendering, post-processing the request results
        without concern whether or not events have been delivered.</para>
      </sect3>

      <sect3>
        <title>InputData and OuputData</title>

        <para>In Aranea one usually does not need to handle request manually
        in custom application widgets. Even more, the request is not
        accessible by default. The usual way to submit custom data to a widget
        and read it is using Aranea Forms (see <xref linkend="forms" />).
        However, when one needs to access the submitted data, one can do that
        using the <literal>org.araneaframework.InputData</literal>. This class
        can be used as follows: <programlisting role="java">...
String myData1 = 
  (String) getInputData().getScopedData().get("myData1");
String globalSubmittedParameter = 
  (String) getInputData().getGlobalData().get("globalSubmittedParameter");
...</programlisting> <literal>getInputData()</literal> is a
        <literal>BaseApplicationWidget</literal> method that returns the input
        data for the current request (one can also use the
        <literal>inputData</literal> parameter given to event listener
        directly). <literal>getScopedData()</literal> returns a
        <literal>java.util.Map</literal> with data submitted to the current
        widget specifically (typically this will mean that the data was
        prefixed with the full widget id in request).
        <literal>getGlobalData()</literal> returns the data that was submitted
        globally (typically the data that was not prefixed anyhow in the
        request).</para>

        <para>One can also obtain the <literal>HttpServletRequest</literal>
        from the <literal>InputData</literal> by calling
        <literal>ServletUtil.getRequest(InputData data)</literal>.</para>

        <para><literal>org.araneaframework.OutputData</literal> usually does
        not play any role in application development. It is accessible through
        the <literal>getOutputData()</literal> method of
        <literal>BaseWidget</literal>. <literal>HttpServletResponse</literal>
        can be accessed by calling <literal>ServletUtil.getResponse(OutputData
        data)</literal>. Additionally <literal>HttpOutputData</literal> also
        has a method <literal>sendRedirect(String location)</literal> which
        should be used as follows: <programlisting role="java">...
((HttpOutputData) getOutputData()).sendRedirect("http://www.google.com");
...</programlisting> This method does an HTTP redirect to the specified
        URL.</para>
      </sect3>

      <sect3>
        <title>View Model and Rendering</title>

        <para><literal>BaseApplicationWidget</literal> also contains methods
        that facilitate transferring data to the presentation layer. This is
        achieved using a <emphasis>View model</emphasis>—an object containing
        a snapshot of the widget current state. The most typical way to use
        the view model it to add data to it:</para>

        <para><programlisting role="java">...
putViewData("today", new Date());
putViewData("currentUser", userBean);
...</programlisting></para>

        <para>View data is typically accessible in the presentation layer as
        some kind of a variable (e.g. a JSP EL variable) for the current
        widget. If the data becomes outdated one can override it using
        <literal>putViewData()</literal> call or remove it using the
        <literal>removeViewData()</literal> call. In case one needs to put
        view data that would last one request only there is an alternative
        method:</para>

        <para><programlisting role="java">...
putViewDataOnce("now", new Date());
...</programlisting></para>

        <para><literal>BaseUIWidget</literal> allows to render the current
        widget using a JSP page. To do that one needs to select a view as
        follows:</para>

        <para><programlisting role="java">...
setViewSelector("myWidget/form");
...</programlisting></para>

        <para>This code makes the widget render itself using the JSP situated
        in <literal>WEB-INF/jsp/myWidget/form.jsp</literal> (of course the
        exact place is configurable). It is also possible to render the widget
        using other template technologies with the same view selector by
        overriding the <literal>render()</literal> method in the base project
        widget.</para>
      </sect3>

      <sect3 id="widgets-example-widget">
        <title>Putting It All Together</title>

        <para>A typical application custom widget will look like that:</para>

        <para><programlisting role="java">public class TestWidget extends BaseUIWidget {

  private static final Logger log = Logger.getLogger(TestWidget.class);
  
  private Data data;
  
  protected void init() throws Exception {
    //Sets the JSP for this widget to "/WEB-INF/jsp/home.jsp"
    setViewSelector("home");
    
    //Get data from the business layer
    data = ((TestService) lookupService("testService")).getData("test parameter");
    
    //Make the data accessible to the JSP for rendering
    putViewData("myData", data);    
  }
  
  /*
   * Event listener method that will process "test" event.
   */
  public void handleEventTest() throws Exception {
    getMessageCtx().showInfoMessage("Test event received successfully");       
  }
}</programlisting></para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Standard Contexts</title>

    <para>Contexts are the Aranea way to access framework services. They can
    be looked up from the environment as shown in <xref
    linkend="widgets-environment" />. This section describes the most common
    Aranea contexts that should be available in any typical configuration. All
    these contexts are also available directly through
    <literal>BaseUIWidget</literal> methods as shown further on.</para>

    <sect2 id="MessageContext">
      <title>MessageContext</title>

      <para><literal>org.araneaframework.framework.MessageContext</literal>
      allows to show messages to the user. The messages can be of several
      types, inluding predefined error and informative types. Typically
      messages will be shown somewhere in the application (exact way is
      application-specific). <literal>MessageContext</literal> is available
      through a <literal>BaseUIWidget</literal> method
      <literal>getMessageCtx()</literal> and is typically used as
      follows:</para>

      <para><programlisting role="java">getMessageCtx().showInfoMessage("Hello world!");</programlisting></para>

      <para>For more information, see <xref
      linkend="StandardMessagingFilterWidget" /> and JavaDoc.</para>
    </sect2>

    <sect2 id="LocalizationContext">
      <title>LocalizationContext</title>

      <para><literal>org.araneaframework.framework.LocalizationContext</literal>
      allows to get and set current session locale, localize strings and
      lookup resource bundles. The context is available through the
      <literal>BaseUIWidget</literal> method <literal>getL10nCtx()</literal>.
      Typically it is used as following:</para>

      <para><programlisting role="java">
...
String message = getL10nCtx().localize("my.message.key");
getMessageCtx().showInfoMessage(message);
...
</programlisting></para>

      <para>More info is available in the JavaDoc.</para>
    </sect2>

    <sect2 id="FlowContext">
      <title>FlowContext</title>

      <para>A common need in a web programming is to support navigation style
      known as <emphasis>flows</emphasis>—interactive stateful processes that
      can navigate to each other passing arguments when needed. A more complex
      case is when we also have flow nesting—a flow can call a subflow, and
      wait for it to finish, then reactivate again. In this case we can have
      at any given moment a stack of flows, where the top one is active, and
      the next one will reactivate when the top one finishes. It is also
      useful if nested flows can return resulting values when they
      finish.</para>

      <para><figure>
          <title>Flow diagram</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="../images/flows.png" format="PNG" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para><literal>org.araneaframework.framework.FlowContext</literal> is
      the Aranea context that provides support for nested flow navigation.
      Aranea flow is a widget that is running in the flow container (using the
      <literal>FlowContext.start()</literal> method. Aranea abstraction for
      the nested state is that of a function—the nested
      <emphasis>flow</emphasis> takes in some parameters and when finished may
      return some value or signal that no value can be returned. The context
      is available as <literal>getFlowCtx()</literal> method of
      <literal>BaseUIWidget</literal> and allows to start flows, finish flows
      and return the resulting value.</para>

      <para>To start a new flow one needs to create a widget as usual. The
      widget may take some parameters in the constructor—they are considered
      to be the incoming parameters of the flow:</para>

      <para><programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), null, null);
...</programlisting></para>

      <para>This call will start a new nested flow for the widget
      <literal>TestFlow</literal> making the current flow inactive.
      <literal>TestFlow</literal> will render and receive event until it
      explicitly returns control to the starting flow. Note that this code
      will start the flow and then return the control, so it is important not
      to do anything in the same method after starting a new flow.</para>

      <para>To end the flow successfully one needs to do as follows:</para>

      <para><programlisting role="java">...
getFlowCtx().finish(new Long(8));
...</programlisting></para>

      <para>This call will finish the current flow (in our case
      <literal>TestFlow</literal>) and return the control to the starting flow
      and its widget.</para>

      <para>Often one needs to handle the return from the flow, processing the
      returned result. This corresponds to our abstraction of a method,
      however since Java does not support continuations we chose to allow the
      caller to register a handler when starting the flow by passing a
      <literal>FlowContext.Handler</literal>:</para>

      <para><programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), null, 
  new FlowContext.Handler() {
    public void onFinish(Object result) {
      getMessageCtx().showInfoMessage("TestFlow returned value " + result);
    }
    public void onCancel() {
      //Ignore cancelled flow
    }
  });
...</programlisting></para>

      <para></para>

      <para>A less common but nevertheless useful feature is to configure the
      starting flow after it has been initialized. For that the caller needs
      to pass a <literal>FlowContext.Configurator</literal>:</para>

      <para><programlisting role="java">...
getFlowCtx().start(new TestFlow(new Long(5)), 
  new FlowContext.Configurator() {
     public void configure(Component comp) {
      ((TestFlow) comp).setStrategy(TestFlow.ATTACK);
     }
  }, null);
...</programlisting></para>

      <para></para>

      <para>Finally <literal>FlowContext</literal> also allows to replace the
      current flow instead of deactivating it by using the
      <literal>replace()</literal> method and to cancel the current flow by
      using the <literal>cancel()</literal> method.</para>

      <para>For standard implementation, please see <xref
      linkend="StandardFlowContainerWidget" /></para>
    </sect2>
  </sect1>
</chapter>