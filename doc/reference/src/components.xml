<!--
  Copyright 2006 Webmedia Group Ltd.
 
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<chapter id="core">
	<title>Core Abstractions</title>
	<sect1>
		<title>Introduction</title>
    <para>
		  Aranea framework and component model are very simple and implemented purely in Plain Old Java. There are no XML mappings, code generation or bytecode enhancement. The whole component model consists mainly of five interfaces: <classname>org.araneaframework.Component</classname>, <classname>org.araneaframework.Service</classname>, <classname>org.araneaframework.Widget</classname>, <classname>org.araneaframework.Environment</classname>, <classname>org.araneaframework.Message</classname> and some conventions regarding their usage and implementation.     
    </para>

    <para>
      
    </para>
	</sect1>
	<sect1>
		<title>Coding Conventions</title>

    <sect2>
      <title>Checked versus Unchecked Exceptions</title>

      <para>
        It is our firm belief that checked exceptions are unnecessary in <emphasis>Controller</emphasis> and therefore Aranea will in most cases allow to just declare that your method <literal>throws Exception</literal>.
      </para>
    </sect2>
    
		<sect2>
			<title>Public versus Framework Interfaces</title>
			
			<para>
				Since the application programmer implements the same components that are used for framework extension, it is important to discourage the access to public framework interfaces (which are necessarily visible in the overridden classes). Thus, a simple convention is applied for core framework interfaces, which is best illustrated with the following example.				
			</para>
			
			<programlisting role="java">public interface Service extends Component, Serializable {
  public Interface _getService();
			
  public interface Interface extends Serializable {
    public void action(Path path, InputData input, OutputData output) throws Exception;
  }
}</programlisting>

			<para>
				As one can see, the real interface methods are relocated to an inner interface named <classname>Interface</classname>, that can be accessed using a method <classname>_get&lt;InterfaceName&gt;()</classname>, which starts with an underscore to discourage its use.
			</para>
			
      </sect2>
		<sect2>
			<title>Components and Their Orthogonal Properties</title>

			<para>
				Aranea has three main types of components: <classname>org.araneaframework.Component</classname>, <classname>org.araneaframework.Service</classname> and <classname>org.araneaframework.Widget</classname>. These components also have a number of orthogonal properties (like <classname>Viewable</classname>, <classname>Composite</classname>), which are represented by interfaces that need to be implemented. Since some particular API methods expect a particular type of component with a particular property (e.g. <classname>ViewableWidget</classname>) one would either have to abandon static type safety or define a lot of meaningless interfaces that would clutter the Javadoc index and confuse the source code readers. The approach chosen in Aranea is to make such interfaces internal to the property, like in the following example.
			</para>

			<programlisting role="java">public interface Viewable extends Serializable {
  public Interface _getViewable();

  interface Interface extends Serializable {
    public Object getViewModel() throws Exception;
  }
  
  public interface ViewableComponent extends Viewable, Component, Serializable {}
  public interface ViewableService extends ViewableComponent, Service, Serializable {}
  public interface ViewableWidget extends ViewableService, Widget, Serializable {}
}</programlisting>
		</sect2>
	</sect1>
	<sect1>
		<title>Components and Environment</title>
    <para>
      <classname>org.araneaframework.Component</classname> represents the unit of encapsulation and reuse in Aranea. Components are used to both provide plug-ins and extensions to the framework and to implement the actual application-specific code. A component has (possibly persistant) state, lifecycle, environment and a messaging mechanism. 
      <programlisting role="java">public interface Component extends Serializable {
  public Component.Interface _getComponent();

  public interface Interface extends Serializable {
    public void init(Environment env) throws Exception;
    public void destroy() throws Exception;
    public void propagate(Message message) throws Exception;
    public void enable() throws Exception;
    public void disable() throws Exception;
  }
}</programlisting>
      The component lifecycle goes as follows:
      <orderedlist spacing="compact">
        <listitem>
          <function>init()</function> &mdash; notifies the component that it should initialize itself passing it the <classname>Environment</classname>. A component can be initialized only once and the environment it is given stays with it until it is destroyed. 
        </listitem>
        <listitem>
          All other calls (like <literal>propagate()</literal>) should be done when a component is alive, initialized and enabled.
        </listitem>
        <listitem>
          <function>disable()</function> &mdash; notifies the component that it will be disabled and will not receive any calls until it is enabled again. A component is enabled by default.
        </listitem>
        <listitem>
          <function>enable()</function> &mdash; notifies the component that it has been enabled again. This call may only be done after a <classname>disable()</classname> call.
        </listitem>
        <listitem>
          <function>destroy()</function> &mdash; notifies the component that it has been destoyed and should release any acquired resources and such. A component can be destroyed only once and should be initialized before that. 
        </listitem>
      </orderedlist>
      Further in the text we will refer to an initialized and not destroyed component instance that has a parent as <emphasis>live</emphasis> and one that has not been disabled or has been re-enabled as <emphasis>enabled</emphasis>.
    </para>

    <para>
      Aranea provides a base implementation of the <literal>Component</literal> &mdash; <literal>org.araneaframework.core.BaseComponent</literal>. This implementation mainly enforces contracts (including lifecycle and some basic synchronization). A base class for application development <literal>org.araneaframework.core.StandardComponent</literal> is also available.
    </para>
		
    <sect2>
			<title>Composite Pattern and Paths</title>

      <para>
        <emphasis>Composite</emphasis> pattern refers to a design approach prominent (specifically) in the GUI modeling when objects implementing the same interface are arranged in a hierarchy by containment, where the nodes of the tree propagate calls in some way to the leafs of the tree.
      </para>

      TODO: UML diagram...

      <para>
       <emphasis>Composite</emphasis> is one of the main patterns used in Aranea. It is mainly used to create a <emphasis>Hierarchical Controller</emphasis> using <literal>Component</literal> containment. In terms of <literal>Component</literal> interface <emphasis>Composite</emphasis> is used to propagate lifecycle events and route messages (see <xref linkend="components-messaging" />). 
      </para>
      <para>
        The flavor of the <emphasis>Composite</emphasis> pattern as used in Aranea typically means that every contained component has some kind of an identifier or name that distinguishes it from other children of the same parent (note that the child is not typically aware of its identifier). This identifiers are used to route messages and events and can be combined to form a full identifier which describes a "path" from the root component to the child in question. This paths are represented by a <emphasis>Iterator</emphasis>-like interface <literal>org.araneaframework.Path</literal>.
        <programlisting role="java">public interface Path extends Cloneable, Serializable {
  public Object getNext();
  public Object next();
  public boolean hasNext();
}</programlisting>        
        Each <literal>next()</literal> call will return the identifier of the next child in the path to the descendant in question. Default implementation (<literal>org.araneaframework.core.CustomPath</literal>) uses simple string identifiers like "a" or "b" and combines them using dots forming full pathes like "a.b.c".
      </para>
      
      <para>
        A <emphasis>Composite</emphasis> component may want to make its children visible to the outside world by implementing the <literal>org.araneaframework.Composite</literal> interface:
<programlisting role="java">public interface Composite extends Serializable {
  public Composite.Interface _getComposite();
  public interface Interface extends Serializable {
    public Map getChildren();
    public void attach(Object key, Component comp);
    public Component detach(Object key); 
  }
}</programlisting>        
      This interface allows to both inspect and manipulate component children by attaching and detaching them from the parent component.
      </para>
      
      <para>
        As most of the Aranea abstractions are built to be used with the <emphasis>Composite</emphasis> concept we will illustrate it in greater detail when examining other abstractions and their implementation. Further on we will assume that any <literal>Component</literal> has a parent that contains it and every child has some kind of name in relation to the parent unless noted otherwise.
      </para>
		</sect2>
		<sect2>
			<title>Component Environment</title>

      <para>
        <literal>org.araneaframework.Environment</literal> is another important concept that represents the way <literal>Component</literal>s interact with the framework. <literal>Environment</literal> interface is rather simple:
<programlisting role="java">public interface Environment extends Serializable {
  public Object getEntry(Object key);
}</programlisting>
        It basically provides means of looking up entry objects by their key. A typical usage of the <literal>Environment</literal> can best be illustrated with an example.
<programlisting role="java">...
MessageContext msgCtx = (MessageContext) getEnvironment().getEntry(MessageContext.class);
msgContext.showInfoMessage("Hello world!");
...</programlisting>
      As one can see from the example <literal>Environment</literal> will typically allow to look up implementations of the interfaces using their <literal>Class</literal> as the key (this is in fact an Aranea convention in using and extending the <literal>Environment</literal>). The interfaces serving as keys for <literal>Environment</literal> entries are referred to as <emphasis>contexts</emphasis>. It is thus not unlike JNDI or some other directory lookups that allow to hold objects, however unlike them <literal>Environment</literal> is very specific to the <literal>Component</literal> it is given to, and can be influenced by its parents. In fact, all contexts available in the <literal>Environment</literal> will be provided to the <literal>Component</literal> by its parents or ancestors (in the sence of containment rather than inheritance). Thus, two different <literal>Component</literal>s may have completely different <literal>Environment</literal>s.
      </para>

      <para>
        A default implementation of <literal>Environment</literal> is <literal>org.araneaframework.core.CustomEnvironment</literal>. It provides for creating an <literal>Environment</literal> from a <literal>java.util.Map</literal>, or extending an existing environment with map entries.
      </para>
		</sect2>
		<sect2 id="components-messaging">
			<title>Messaging Components</title>

      <para>
        So far, we have looked at the component management and environment. However what makes the component hierarchy such a powerful concept is messaging. Basically, messaging allows us to send any events to any component in the hierarchy (including all components or a specific one). The messaging is incorporated using the <literal>org.araneaframework.Message</literal> interface
<programlisting role="java">public interface Message extends Serializable {
  public void send(Object id, Component component) throws Exception;
}</programlisting>
  and <literal>Component.propagate(Message message)</literal> method. The default behavior of the <literal>propagate()</literal> method should be to send the message to all component children, passing the <literal>send()</literal> method the identifier of the child and the child itself. It is up to the message what to do with the child further, but typically some form of <emphasis>double-dispatch</emphasis> takes place and message propagates itself further. 
  </para>
  
  TODO: explain double-dispatch
  
  <para>A standard <literal>Message</literal> implementation that uses double-dispatch to visit all the components in hierarchy is <literal>org.araneaframework.core.CustomMessage</literal>. It usage can be illustrated with the following example:
<programlisting role="java">...
Message myEvent = new StandardMessage() {
  public void execute(Component component) throws Exception {
  if (component instanceof MyEventListener)
    ((MyEventListener) component).onMyEvent(data);
  }
}
myEvent.send(null, rootComponent);
...</programlisting>
  This code will call all the components in the hierarchy that subscribed to the event and pass them a certain <literal>data</literal> parameter. As one can see, when calling <literal>Message.send()</literal> we will typically pass <literal>null</literal> as the first parameter, since it is needed only when propagating messages further down the hierarchy. Note that messages can be used to gather data from the components just as well as for passing data to them (TODO: Elaborate?).
      </para>

      <para>
        Another standard <literal>Message</literal> implementation is <literal>org.araneaframework.StandardRoutedMessage</literal>, which allows us to send a message to one specific component in the hierarchy as in the following example:
<programlisting role="java">...
Message myEvent = new StandardRoutedMessage("a.b.c") {
  public void execute(Component component) throws Exception {
    ((MyPersonalComponent) component).myMethod(...);
  }
}
myEvent.send(null, rootComponent);
...</programlisting>
    This code will send the message to the specific component with path "a.b.c" and call <literal>myMethod()</literal> on it.
      </para>
		</sect2>

    <sect2 id="components-persistence">
      <title>Persistent State</title>

      <para>
        The handling of persistent state in Aranea is very simple. There are no scopes and every component state is saved until it is explicitly removed by its parent. This does not mean that all of the components are bound to the session, but rather that most components will live a period of time appropriate for them (e.g. framework components will live as long as the application lives, GUI components will live until user leaves them, and so on). This provides for a very flexible approach to persistence allowing not to clutter memory with unused components. 
      </para>

      <para>
        The end result is that typically one needs not worry about persistence at all, unless one is programming some framework plug-ins. All class fields (except in some cases <literal>transient</literal> fields) can be assumed to persist while the host object is <emphasis>live</emphasis>.
      </para>
    </sect2>

    <sect2 id="components-standard-component">
      <title>StandardComponent</title>

      <para>
        <literal>org.araneaframework.core.CustomComponent</literal> is the base class for application-specific components. It implements <emphasis>Composite</emphasis> pattern allowing to add, remove, enable and disable children and propagates messages to all the children. 
      </para>
    </sect2>
  </sect1>
  <sect1 id="components-io-data">
    <title>InputData and OutputData</title>

    <para>
      <literal>InputData</literal> is Aranea abstraction for a request, which hides away the Servlet API and allows us to run Aranea on different containers (e.g. in a portlet or behind a web service). 
      </para>
      
    <para>
      Both <literal>InputData</literal> and <literal>OutputData</literal> have a <emphasis>scope</emphasis>, which  is  information about the path to the current component. When they are propagated through the component hierarchy the following methods are used to construct the scope (note that these methods should be used only when using <emphasis>Composite</emphasis> components, as framework components are scoped differently):
<itemizedlist spacing="compact">
<listitem><literal>pushScope(Object step)</literal> is used to add the child's identifier to the end of the current scope and should be used before the call to the child</listitem>
<listitem><literal>popScope()</literal> is used to remove the last identifier from the scope</listitem>
<listitem><literal>getScope()</literal> will return the current scope as a <literal>Path</literal></listitem>
</itemizedlist>        
    </para>

    <para>
      <literal>InputData</literal> also provides access to the data sent to the component. This data comes in two flavours: 
      <itemizedlist spacing="compact">
        <listitem>
          <literal>getScopedData()</literal> returns a <literal>java.util.Map</literal> with the data sent specially to this component, which is associated with the current scope.
        </listitem>   
        <listitem>
          <literal>getGlobalData()</literal> returns a <literal>java.util.Map</literal> with the data sent to the application generally. 
        </listitem>
      </itemizedlist>
      In case Aranea is running on top of a servlet both these maps will contain only <literal>String</literal>s (or in case you submitted more than one value for a specific key it may contain a <literal>String[]</literal>). In case of the usual path and scope implementation (as dot-separated strings) <emphasis>global data</emphasis> will contain the submitted parameters with no dots in them and <emphasis>scoped data</emphasis> will contain the parameters prefixed with the current component scope string.
     </para>

     TODO: is it this way?

     <para>
      The main function of <literal>OutputData</literal> is to propagate attributes that are used when delegating rendering to a templating engine or by children to access some general information during rendering. The following methods are used to propagate these attributes:
      <itemizedlist spacing="compact">
        <listitem>
          <literal>void pushAttribute(Object key, Object value)</literal> registers the object <literal>value</literal> under the key <literal>key</literal>. If some other component have already propagated an attribute under this key, then it will be temporary overridden.
        </listitem>   
        <listitem>
          <literal>Object popAttribute(Object key)</literal> deregisters the object from under the key <literal>key</literal>. If the attribute was temporary overridden it will restore the previous attribute value.
        </listitem>   
        <listitem>
          <literal>Object getAttribute(Object key)</literal> returns the last object registered under key <literal>key</literal>.
        </listitem>   
        <listitem>
          <literal>Map getAttributes()</literal> returns all currently registered attributes.
        </listitem>   
      </itemizedlist>        
     </para>

     <para>
       Finally, as <literal>InputData</literal> and <literal>OutputData</literal> are typically connected, they can be retrieved from the other <literal>*Data</literal> structure using correspondingly <literal>getCurrentOutputData()</literal> and <literal>getCurrentInputData()</literal> methods.
     </para>
  </sect1>
	<sect1>
		<title>Services</title>
    <para>
      <literal>org.araneaframework.Service</literal> is a basic abstraction over an event-driven <emphasis>Controller</emphasis> pattern that inherits lifecycle, environment and messaging from the <literal>Component</literal>. The difference from the <literal>Component</literal> is as follows:
<programlisting role="java">public interface Service extends Component, Serializable {
  public Interface _getService();

  public interface Interface extends Serializable {
    public void action(Path path, InputData input, OutputData output) throws Exception;
  }
}</programlisting>
    The method <literal>action()</literal> is similar to the <literal>service()</literal> method in the Servlet API, <literal>InputData</literal> being an abstraction over a request and <literal>OutputData</literal> being an abstraction over a response (see <xref linkend="components-io-data"/>). Thus a service will both process the request parameters and render itself during this method call. However unlike servlets services can be <emphasis>Composite</emphasis> and may be defined both statically (on application startup) or dynamically (adding/removing new services on the fly).
    </para>

    <para>
      Services are the basic working horses of the Aranea framework. They  can generally be both synchronized and unsynchronized depending on the context. Services may also have persistent state and their lifetime is explicitly managed by their parent (see <xref linkend="components-persistence"/>). The service lifecycle is very simple&mdash;as long as the service is live and enabled it can receive <literal>action()</literal> calls, possibly several at a time. 
    </para>
    
		<sect2>
			<title>Services as Framework Plug-ins</title>

      <para>
        Services make up most of the actual Aranea framework. Even though they are simple, they can implement the following patterns:

        <variablelist>
          <varlistentry>
            <term>Filter</term>
            <listitem>
              Filter service is the simplest. It contains a single unnamed child service and implements the <emphasis>Filter</emphasis> pattern by either passing the call to the child or not. However in addition to that it may enrich the child environment with contexts and provide more functionality like exception handling or synchronization. Typical examples of filter services are localization service (provides a localization context), synchronization service (synchronizes on <literal>action()</literal> method) and transactional service that does not let through double submits.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Router</term>
            <listitem>
              Router service typically contains many named child services, and chooses only one to propagate the <literal>action()</literal> call according to some <literal>InputData</literal> parameter. Router service may have the child services statically preconfigured or it may create them dynamically when the request comes (the latter is the case with session service router). It may also allow us to add/remove children while the application is running. A typical application of a router is to distinguish among major application parts by some attribute (like component corresponding to a user session, or one of the popup window of current user).
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Container</term>
            <listitem>
              Container services can have one or many children, but they typically will do more with them than just calling <literal>action()</literal> on one of them. A typical example is the <emphasis>widget container</emphasis> service which translates <literal>action()</literal> calls into widget request-response cycle calls.
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
		</sect2>
	</sect1>
	<sect1 id="components-widgets">
		<title>Widgets</title>
    <para>
      While services and components are used mainly in the framework itself, <literal>org.araneaframework.Widget</literal> is the main concept used when programming applications and even reusable GUI elements. Unlike services, widgets assume that calls are synchronized and in fact have a request-response cycle which is all assumed to occur in one thread only. This allows to program widgets without any concern for persistence (see <xref linkend="components-persistence"/>) or synchronization implementing widgets as any other Java classes. 
    </para>

    <para>
      Widgets extend services with a request-response cycle:
<programlisting role="java">public interface Widget extends Service, Serializable {
  public Interface _getWidget();
  
  public interface Interface extends Serializable {
    public void update(InputData data) throws Exception;
    public void event(Path path, InputData input) throws Exception;
    public void process() throws Exception;
    public void render(OutputData output) throws Exception;
  } 
}</programlisting>
    Although widgets extend services, a widget will function during one request either as a widget or as a service&mdash;that is if a widget receives an <literal>action()</literal> call no other request-response cycle calls can occur.
    </para>

    <para>
      The widget request-response cycle proceeds as follows:
      <orderedlist spacing="compact">
        <listitem>
          <literal>update()</literal>&mdash;this method is called for all the widgets in the hierarchy. It allows widgets to read the data from request and possibly store some conversation state or at least temporary information to render the next view. 
        </listitem>
        <listitem>
          <literal>event()</literal>&mdash;this method is called on only one widget in the hierarchy. It allows to send widgets events from the user. The <literal>path</literal> is used to route the event to the correct widget and is empty when the event is delivered to its endpoint. This method is optional in the widget request-response cycle.
        </listitem>
        <listitem>
          <literal>process()</literal>&mdash;this method is called on all the widgets in the hierarchy. It allows widgets to process the result of <literal>event()</literal> and <literal>update()</literal> calls before rendering.
        </listitem>
        <listitem>
          <literal>render()</literal>&mdash;the way this method is called depends on how widgets are rendered (see <xref linkend="components-render"/>). It may be called only after <literal>process()</literal> and may be called more than once (or not at all) during one request-response cycle. 
        </listitem>
      </orderedlist>
    </para>
		<sect2 id="components-render">
			<title>ViewModel and Rendering</title>
 
      <para>
        The default model of both widget and service rendering is that they render themselves. However, in most cases the widget might want to delegate the rendering to some templating language. In some other cases the widget might be rendered externally, without calling <literal>render()</literal> at all. Further on, we will describe these three cases in detail.
        <variablelist>
          <varlistentry>
            <term>Self-rendering</term>
            <listitem>
              In the most basic situation the widget will just use <literal>OutputData</literal> for rendering by casting it into e.g. <literal>ServletOutputData</literal>. In such a case the widget will just write out markup and return from the <literal>render()</literal> method optionally rendering children as well. The data for rendering will be drawn from the widget fields as well as (possibly) <literal>OutputData</literal> attributes.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Using templates for rendering</term>
            <listitem>
              The most common case in application widgets is to delegate rendering to a templating language. A widget may basically choose to render itself in arbitrary templating language as Aranea does not impose any restrictions. In fact, one widget may be rendered with one templating language, while another one with a completely different language. The template can gain access to the widget using the knowledge of the widget's full name (which is gathered in the <literal>OutputData</literal> scope). It is then possible  to acquire the widget View Model, which is a read-only representation of the widget state. For that the widget should implement <literal>org.araneaframework.Viewable</literal>:
<programlisting role="java">public interface Viewable extends Serializable {
  public Interface _getViewable();

  interface Interface extends Serializable {
    public Object getViewModel() throws Exception;
  }  
}</programlisting>              
            View model is put together by the widget being rendered and should contain all the data necessary to render the widget.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>External rendering</term>
            <listitem>
              Finally, a widget <literal>render()</literal> method may not be called altogether and a <literal>Viewable</literal> widget may be rendered externally using the available View Model. This is the case with some reusable widgets which are rendered using e.g. JSP tags.
            </listitem>
          </varlistentry>
        </variablelist>
      </para>
		</sect2>
	</sect1>
</chapter>
