<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;2.&nbsp;Components, Widgets and Services</title><link rel="stylesheet" href="../css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="Aranea&#8212;Java Web Framework Construction and Integration Kit"><link rel="up" href="index.html" title="Aranea&#8212;Java Web Framework Construction and Integration Kit"><link rel="prev" href="intro.html" title="Chapter&nbsp;1.&nbsp;Introduction"><link rel="next" href="framework.html" title="Chapter&nbsp;3.&nbsp;Framework and Configuration"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;2.&nbsp;Components, Widgets and Services</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="intro.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="framework.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="core"></a>Chapter&nbsp;2.&nbsp;Components, Widgets and Services</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e220"></a>2.1.&nbsp;Introduction</h2></div></div></div><p>Aranea framework and component model are very simple and implemented
    purely in Plain Old Java. There are no XML mappings, code generation or
    bytecode enhancement. The whole component model consists mainly of five
    interfaces: <code class="classname">org.araneaframework.Component</code>,
    <code class="classname">org.araneaframework.Service</code>,
    <code class="classname">org.araneaframework.Widget</code>,
    <code class="classname">org.araneaframework.Environment</code>,
    <code class="classname">org.araneaframework.Message</code> and some conventions
    regarding their usage and implementation.</p><p>This chapter describes the core Aranea abstractions in detail
    generally not necessary to just develop application code so it can be
    skipped during the first reading. It is quite dry on the examples, but its
    understanding is crucial to develop Aranea extensions. To get a quick
    understanding of how to program applications with widgets read <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>. </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e244"></a>2.2.&nbsp;Coding Conventions</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e247"></a>2.2.1.&nbsp;Checked versus Unchecked Exceptions</h3></div></div></div><p>It is our firm belief that checked exceptions are unnecessary in
      <span class="emphasis"><em>Controller</em></span> and therefore Aranea will in most cases
      allow to just declare your overriding method as <code class="literal">throws
      Exception</code>. On the other hand no framework interfaces throw
      checked exceptions so the exception-handling boilerplate can be
      delegated to a single error-handling component.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e258"></a>2.2.2.&nbsp;Public versus Framework Interfaces</h3></div></div></div><p>Since the application programmer implements the same components
      that are used for framework extension, it is important to discourage the
      access to public framework interfaces (which are necessarily visible in
      the overridden classes). Thus a simple convention is applied for core
      framework interfaces, which is best illustrated with the following
      example.</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Service <span class="syntax6">extends</span> Component, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getService</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(Path path, InputData input, OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>As one can see, the real interface methods are relocated to an
      inner interface named <code class="classname">Interface</code>, that can be
      accessed using a method
      <code class="classname">_get&lt;InterfaceName&gt;()</code>, which starts with an
      underscore to discourage its use. As a rule of a thumb, in Aranea the
      methods starting with an underscore should only be used, when one really
      knows what one is doing.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e273"></a>2.2.3.&nbsp;Components and Their Orthogonal Properties</h3></div></div></div><p>Aranea has three main types of components:
      <code class="classname">org.araneaframework.Component</code>,
      <code class="classname">org.araneaframework.Service</code> and
      <code class="classname">org.araneaframework.Widget</code>. These components also
      have a number of orthogonal properties (like
      <code class="classname">Viewable</code>, <code class="classname">Composite</code>),
      which are represented by interfaces that need to be implemented. Since
      some particular API methods expect a particular type of component with a
      particular property (e.g. <code class="classname">ViewableWidget</code>) one
      would either have to abandon static type safety or define a lot of
      meaningless interfaces that would clutter the Javadoc index and confuse
      the source code readers. The approach chosen in Aranea is to make such
      interfaces internal to the property, like in the following
      example.</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Viewable <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getViewable</span>();

  <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Object <span class="syntax9">getViewModel</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableComponent <span class="syntax6">extends</span> Viewable, Component, Serializable <span class="syntax11">{}</span>
  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableService <span class="syntax6">extends</span> ViewableComponent, Service, Serializable <span class="syntax11">{}</span>
  <span class="syntax6">public</span> <span class="syntax8">interface</span> ViewableWidget <span class="syntax6">extends</span> ViewableService, Widget, Serializable <span class="syntax11">{}</span>
<span class="syntax11">}</span>
</span></pre></pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-components-environment"></a>2.3.&nbsp;Components and Environment</h2></div></div></div><p><code class="classname">org.araneaframework.Component</code> represents the
    unit of encapsulation and reuse in Aranea. Components are used to both
    provide plug-ins and extensions to the framework and to implement the
    actual application-specific code. A component has (possibly persistent)
    state, life cycle, environment and a messaging mechanism. </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Component <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Scope <span class="syntax9">getScope</span>();             <span class="syntax2">/**</span><span class="syntax2"> </span><span class="syntax5">@since</span><span class="syntax2"> 1.1 </span><span class="syntax2">*/</span>
  <span class="syntax6">public</span> Environment <span class="syntax9">getEnvironment</span>(); <span class="syntax2">/**</span><span class="syntax2"> </span><span class="syntax5">@since</span><span class="syntax2"> 1.1 </span><span class="syntax2">*/</span>
  <span class="syntax6">public</span> <span class="syntax8">boolean</span> <span class="syntax9">isAlive</span>();            <span class="syntax2">/**</span><span class="syntax2"> </span><span class="syntax5">@since</span><span class="syntax2"> 1.1 </span><span class="syntax2">*/</span>

  <span class="syntax6">public</span> Component.Interface <span class="syntax9">_getComponent</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">init</span>(Environment env) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">destroy</span>() <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">propagate</span>(Message message) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">enable</span>() <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">disable</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>The component life cycle goes as follows: </p><div class="orderedlist"><ol type="1" compact><li><code class="function">init()</code>

           &#8212;notifies the component that it should initialize itself passing it the 

          <code class="classname">Environment</code>

           . A component can be initialized only once and the environment it is given stays with it until it is destroyed. 
        </li><li>
           All other calls (like 

          <code class="literal">propagate()</code>

           ) should be done when a component is alive, initialized and enabled. 
        </li><li><code class="function">disable()</code>

           &#8212;notifies the component that it will be disabled and will not receive any calls until it is enabled again. A component is enabled by default. 
        </li><li><code class="function">enable()</code>

           &#8212;notifies the component that it has been enabled again. This call may only be done after a 

          <code class="classname">disable()</code>

           call. 
        </li><li><code class="function">destroy()</code>

           &#8212;notifies the component that it has been destroyed and should release any acquired resources and such. A component can be destroyed only once and should be initialized before that. 
        </li></ol></div><p> Further in the text we will refer to an initialized and
    not destroyed component instance that has a parent as
    <span class="emphasis"><em>live</em></span> and one that has not been disabled or has been
    re-enabled as <span class="emphasis"><em>enabled</em></span>.</p><p>Aranea provides a base implementation of the
    <code class="literal">Component</code> &#8212;
    <code class="literal">org.araneaframework.core.BaseComponent</code>. This
    implementation mainly enforces contracts (including life cycle and some
    basic synchronization). A base class for application development
    <code class="literal">org.araneaframework.core.BaseApplicationComponent</code> is
    also available.</p><p>
    	<code class="literal">Component</code> methods not dealing with lifecycle or messaging are accessible 
    	without getting at <code class="literal">Component.Interface</code>. <code class="literal">Component.getScope()</code> 
    	returns scoped identifier that uniquely identifies that <code class="literal">Component</code> in component
    	hierarchy. <code class="literal">Component.getEnvironment()</code> returns information of <code class="literal">Environment</code> 
    	in which <code class="literal">Component</code> lives and <code class="literal">Component.isAlive()</code> allows
    	component to check whether it is living at all :). 
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e381"></a>2.3.1.&nbsp;Composite Pattern and Paths</h3></div></div></div><p><span class="emphasis"><em>Composite</em></span> pattern refers to a design approach
      prominent (specifically) in the GUI modeling when objects implementing
      the same interface are arranged in a hierarchy by containment, where the
      nodes of the tree propagate calls in some way to the leafs of the tree.
      It is shown on <a href="core.html#composite-pattern" title="Figure&nbsp;2.1.&nbsp;Composite design pattern">Figure&nbsp;2.1, &#8220;<span class="emphasis"><em>Composite</em></span> design pattern&#8221;</a>.</p><div class="figure"><a name="composite-pattern"></a><div class="mediaobject"><img src="../images/composite.png" alt="Composite design pattern"></div><p class="title"><b>Figure&nbsp;2.1.&nbsp;<span class="emphasis"><em>Composite</em></span> design pattern</b></p></div><p><span class="emphasis"><em>Composite</em></span> is one of the main patterns used in
      Aranea. It is mainly used to create a <span class="emphasis"><em>Hierarchical
      Controller</em></span> using <code class="literal">Component</code> containment. In
      terms of <code class="literal">Component</code> interface
      <span class="emphasis"><em>Composite</em></span> is used to propagate life cycle events
      and route messages (see <a href="core.html#components-messaging" title="2.3.3.&nbsp;Messaging Components">Section&nbsp;2.3.3, &#8220;Messaging Components&#8221;</a>).</p><p>The flavor of the <span class="emphasis"><em>Composite</em></span> pattern as used
      in Aranea typically means that every contained component has some kind
      of an identifier or name that distinguishes it from other children of
      the same parent (note that the child is not typically aware of its
      identifier). This identifiers are used to route messages and events and
      can be combined to form a full identifier which describes a "path" from
      the root component to the child in question. This paths are represented
      by a <span class="emphasis"><em>Iterator</em></span>-like interface
      <code class="literal">org.araneaframework.Path</code>. </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Path <span class="syntax6">extends</span> Cloneable, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Object <span class="syntax9">getNext</span>();
  <span class="syntax6">public</span> Object <span class="syntax9">next</span>();
  <span class="syntax6">public</span> <span class="syntax8">boolean</span> <span class="syntax9">hasNext</span>();
<span class="syntax11">}</span>
</span></pre></pre><p>Each <code class="literal">next()</code> call will return the identifier of
      the next child in the path to the descendant in question. Default
      implementation
      (<code class="literal">org.araneaframework.core.StandardPath</code>) uses simple
      string identifiers like "a" or "b" and combines them using dots forming
      full paths like "a.b.c".</p><p>A <span class="emphasis"><em>Composite</em></span> component may want to make its
      children visible to the outside world by implementing the
      <code class="literal">org.araneaframework.Composite</code> interface:
      </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Composite <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Composite.Interface <span class="syntax9">_getComposite</span>();
  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Map <span class="syntax9">getChildren</span>();
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">attach</span>(Object key, Component comp);
    <span class="syntax6">public</span> Component <span class="syntax9">detach</span>(Object key); 
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>This interface allows to both inspect and manipulate component
      children by attaching and detaching them from the parent
      component.</p><p>As most of the Aranea abstractions are built to be used with the
      <span class="emphasis"><em>Composite</em></span> concept we will illustrate it in greater
      detail when examining other abstractions and their implementation.
      Further on we will assume that any <code class="literal">Component</code> has a
      parent that contains it and every child has some kind of name in
      relation to the parent unless noted otherwise (obviously there is at
      least one <span class="emphasis"><em>Composite</em></span> that does not have a parent,
      but we don't really care about that at the moment).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="core-environment"></a>2.3.2.&nbsp;Environment</h3></div></div></div><p><code class="literal">org.araneaframework.Environment</code> is another
      important concept that represents the way <code class="literal">Component</code>s
      interact with the framework. <code class="literal">Environment</code> interface is
      rather simple: </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Environment <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Object <span class="syntax9">getEntry</span>(Object key);
  <span class="syntax6">public</span> Object <span class="syntax9">requireEntry</span>(Object key) <span class="syntax6">throws</span> NoSuchEnvironmentEntryException;
<span class="syntax11">}</span>
</span></pre></pre><p>It basically provides means of looking up entry objects by their
      key. A typical usage of the <code class="literal">Environment</code> can be
      illustrated with an example. </p><pre class="programlisting"><pre><span class="syntax0">...
MessageContext msgCtx <span class="syntax11">=</span> (MessageContext) <span class="syntax9">getEnvironment</span>().<span class="syntax9">getEntry</span>(MessageContext.<span class="syntax8">class</span>);
msgContext.<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
...
</span></pre></pre><p>As one can see from the example <code class="literal">Environment</code>
      will typically allow to look up implementations of the interfaces using
      their <code class="literal">Class</code> as the key (this is in fact an Aranea
      convention in using and extending the <code class="literal">Environment</code>).
      The interfaces serving as keys for <code class="literal">Environment</code>
      entries are referred to as <span class="emphasis"><em>contexts</em></span>. It is thus not
      unlike JNDI or some other directory lookups that allow to hold objects,
      however unlike them <code class="literal">Environment</code> is very specific to
      the <code class="literal">Component</code> it is given to, and can be influenced
      by its parents. In fact, all contexts available in the
      <code class="literal">Environment</code> will be provided to the
      <code class="literal">Component</code> by its parents or ancestors (in the sense
      of containment rather than inheritance). Thus, two different
      <code class="literal">Component</code>s may have completely different
      <code class="literal">Environment</code>s.</p><p>A default implementation of <code class="literal">Environment</code> is
      <code class="literal">org.araneaframework.core.StandardEnvironment</code>. It
      provides for creating an <code class="literal">Environment</code> from a
      <code class="literal">java.util.Map</code>, or extending an existing environment
      with map entries.</p><p>A component can provide an environment entry to its descendant, by
      providing it to the initializer of its direct child. For instance the
      <code class="literal">MessageContext</code> could be provided by the following
      message component:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> MessageFilterService <span class="syntax6">implements</span> MessageContext, Component, Service <span class="syntax11">{</span>
  <span class="syntax6">protected</span> Service childService;
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">setChildService</span>(Service childService) <span class="syntax11">{</span>
    <span class="syntax4">this</span>.childService <span class="syntax11">=</span> childService;
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">init</span>(Environment env) <span class="syntax11">{</span>
    childService.<span class="syntax9">init</span>(
      <span class="syntax6">new</span> <span class="syntax9">StandardEnvironment</span>(env, MessageContext.<span class="syntax8">class</span>, <span class="syntax4">this</span>);
  <span class="syntax11">}</span>

  <span class="syntax1">//MessageContext implementation...</span>
  <span class="syntax6">public</span> String <span class="syntax9">showInfoMessage</span>(String message) <span class="syntax11">{</span>
    <span class="syntax1">//Show message to user...</span>
  <span class="syntax11">}</span>  

  <span class="syntax1">//...</span>
<span class="syntax11">}</span>
</span></pre></pre><p>After that the <code class="literal">childService</code>, its children and
      so on will be able to use the <code class="literal">MessageContext</code> provided
      by <code class="literal">MessageFilterService</code>. Of course this can be done
      simpler as shown in examples in this chapter, but this is how most of the
      components in Aranea provide new contexts to the <code class="literal">Environment</code>.
      </p><p>Sometimes, however, one may want to make his or her component or widget
 			 independent from the specific <code class="literal">Environment</code>. This can be achieved
 			 by using <code class="literal">org.araneaframework.core.RelocatableDecorator</code>:
</p><pre class="programlisting"><pre><span class="syntax0">  Service child <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">RelocatableDecorator</span>(<span class="syntax6">new</span> <span class="syntax9">MyWidget</span>());
  <span class="syntax9">addWidget</span>(<span class="syntax3">"c"</span>, child);
</span></pre></pre><p>

			For example, this technique is used when a user clones a thread (middle mouse button
			click on a link), and it is necessary to clone the state. Then each widget is cloned,
			and a new <code class="literal">Environmnet</code> is provided to them.
 			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-messaging"></a>2.3.3.&nbsp;Messaging Components</h3></div></div></div><p>So far, we have looked at the component management and
      environment. However what makes the component hierarchy such a powerful
      concept is messaging. Basically, messaging allows us to send any events
      to any component in the hierarchy (including all components or a
      specific one). The messaging is incorporated using the
      <code class="literal">org.araneaframework.Message</code> interface </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Message <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">send</span>(Object id, Component component) <span class="syntax6">throws</span> Exception;
<span class="syntax11">}</span>
</span></pre></pre><p> and <code class="literal">Component.propagate(Message message)</code>
      method. The default behavior of the <code class="literal">propagate()</code>
      method should be to send the message to all component children, passing
      the <code class="literal">send()</code> method the identifier of the child and the
      child itself. It is up to the message what to do with the child further,
      but typically <code class="literal">Message</code> just calls the
      <code class="literal">propagate()</code> method of the child passing itself as the
      argument after possibly doing some custom processing (the
      <span class="emphasis"><em>double-dispatch</em></span> OO idiom).</p><p>A standard <code class="literal">Message</code> implementation that uses
      double-dispatch to visit all the components in hierarchy is
      <code class="literal">org.araneaframework.core.BroadcastMessage</code>. It usage
      can be illustrated with the following example: </p><pre class="programlisting"><pre><span class="syntax0">...
Message myEvent <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">BroadcastMessage</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
  <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> MyEventListener)
    ((MyEventListener) component).<span class="syntax9">onMyEvent</span>(data);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
myEvent.<span class="syntax9">send</span>(<span class="syntax4">null</span>, rootComponent);
...
</span></pre></pre><p> This code will call all the components in the hierarchy
      that subscribed to the event and pass them a certain
      <code class="literal">data</code> parameter. As one can see, when calling
      <code class="literal">Message.send()</code> we will typically pass
      <code class="literal">null</code> as the first parameter, since it is needed only
      when propagating messages further down the hierarchy. Note that messages
      can be used to gather data from the components just as well as for
      passing data to them. For example one could construct message that
      gathers all <code class="literal">FormWidget</code>s from the widget
      hierarchy:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax6">static</span> <span class="syntax8">class</span> FormWidgetFinderMessage <span class="syntax6">extends</span> BroadcastMessage <span class="syntax11">{</span>
  List formList <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">ArrayList</span>();

  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> org.araneaframework.uilib.form.FormWidget) <span class="syntax11">{</span>
      formList.<span class="syntax9">add</span>(component);
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>

  <span class="syntax6">public</span> List <span class="syntax9">getAllForms</span>() <span class="syntax11">{</span> <span class="syntax6">return</span> formList; <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Another standard <code class="literal">Message</code> implementation is
      <code class="literal">org.araneaframework.core.RoutedMessage</code>, which allows
      us to send a message to one specific component in the hierarchy as in
      the following example: </p><pre class="programlisting"><pre><span class="syntax0">...
Message myEvent <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">RoutedMessage</span>(<span class="syntax3">"a.b.c"</span>) <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    ((MyPersonalComponent) component).<span class="syntax9">myMethod</span>(...);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
myEvent.<span class="syntax9">send</span>(<span class="syntax4">null</span>, rootComponent);
...
</span></pre></pre><p> This code will send the message to the specific component
      with path "a.b.c" and call <code class="literal">myMethod()</code> on it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-persistence"></a>2.3.4.&nbsp;State and Synchronization</h3></div></div></div><p>The handling of persistent state in Aranea is very simple. There
      are no scopes and every component state is saved until it is explicitly
      removed by its parent. This does not mean that all of the components are
      bound to the session, but rather that most components will live a period
      of time appropriate for them (e.g. framework components will live as
      long as the application lives, GUI components will live until user
      leaves them, and so on). This provides for a very flexible approach to
      persistence allowing not to clutter memory with unused
      components.</p><p>The end result is that typically one needs not worry about
      persistence at all, unless one is programming some framework plug-ins.
      All class fields (except in some cases <code class="literal">transient</code>
      fields) can be assumed to persist while the host object is
      <span class="emphasis"><em>live</em></span>.</p><p>However such handling does not guarantee that the component state
      is anyhow synchronized. As a matter of fact most of the framework
      components outside the user session should be able to process concurrent
      calls and should take care of the synchronization themselves. However
      application components are typically synchronized by the framework. More
      information on the matter will follow in <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-io-data"></a>2.4.&nbsp;InputData and OutputData</h2></div></div></div><p><code class="literal">InputData</code> is Aranea abstraction for a request,
    which hides away the Servlet API and allows us to run Aranea on different
    containers (e.g. in a portlet or behind a web service).</p><p><code class="literal">InputData</code> provides access to the data sent
    to the component. This data comes in two flavours: </p><div class="itemizedlist"><ul type="disc" compact><li><code class="literal">getScopedData(Path scope)</code>

           returns a 

          <code class="literal">java.util.Map</code>

           with the data sent specially to <code class="literal">component</code>, which unique identifier in
           the component hierarchy is <code class="literal">scope</code>. To get at this data, one can
           use construction <code class="literal">inputData.getScopedData(getScope().toPath())</code> from 
           a component. 
        </li><li><code class="literal">getGlobalData()</code>

           returns a 

          <code class="literal">java.util.Map</code>

           with the data sent to the application generally. 
        </li></ul></div><p> In case Aranea is running on top of a servlet both these
    maps will contain only <code class="literal">String</code>s. If one wants to access
    multi-valued parameters in servlet environment <code class="literal">StandardServletInputData.getParameterValues(String name)</code>
    method should be used (returns <code class="literal">String</code> array).

    In case of the usual path and scope implementation (as dot-separated strings) <span class="emphasis"><em>global data</em></span>
    will contain the submitted parameters with no dots in them and
    <span class="emphasis"><em>scoped data</em></span> will contain the parameters prefixed with
    the current component scope string.</p><p>Analogically <code class="literal">OutputData</code> is Aranea abstraction for response. <code class="literal">HttpOutputData</code> being
    the subinterface and <code class="literal">StandardServletOutputData</code> implementation for servlet environments.</p><p>As <code class="literal">InputData</code> and
    <code class="literal">OutputData</code> are typically connected, they can be
    retrieved from the other <code class="literal">*Data</code> structure using
    correspondingly <code class="literal">getOutputData()</code> and
    <code class="literal">getInputData()</code> methods.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e732"></a>2.4.1.&nbsp;Extensions</h3></div></div></div><p>Both InputData and OutputData implement a way to extend their
      functionality without wrapping or extending the objects themselves. This
      is achieved by providing the following two methods:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax8">void</span> <span class="syntax9">extend</span>(Class interfaceClass, Object extension)
Object <span class="syntax9">narrow</span>(Class interfaceClass);
</span></pre></pre><p>The following example should give an idea of applying these
      methods:</p><pre class="programlisting"><pre><span class="syntax0">input.<span class="syntax9">extend</span>(FileUploadExtension.<span class="syntax8">class</span>, <span class="syntax6">new</span> <span class="syntax9">FileUploadExtension</span>(input));

...

FileUploadExtension fileUploadExt <span class="syntax11">=</span> 
  (FileUploadExtension) input.<span class="syntax9">narrow</span>(FileUploadExtension.<span class="syntax8">class</span>);
<span class="syntax6">if</span> (fileUploadExt.<span class="syntax9">uploadSucceeded</span>()) <span class="syntax11">{</span>
  <span class="syntax1">//...</span>
<span class="syntax11">}</span>
</span></pre></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Both <code class="literal">HttpServletRequest</code> and
        <code class="literal">HttpServletResponse</code> are available as
        <code class="literal">InputData</code> and <code class="literal">OutputData</code>
        extensions respectively.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e760"></a>2.4.2.&nbsp;HttpInputData and HttpOutputData</h3></div></div></div><p>Although all of the core Aranea abstractions are independent of
      the Servlet API and web in general, we also provide a way to manipulate
      low-level HTTP constructs. To that goal we provide two interfaces,
      <code class="literal">HttpInputData</code> and <code class="literal">HttpOutputData</code>,
      which extend respectively <code class="literal">InputData</code> and
      <code class="literal">OutputData</code>.</p><p>Let's examine the <code class="literal">HttpInputData</code>. First of all
      it provides methods that are similar to the ones found in the
      <code class="literal">HttpServletRequest</code>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">Iterator getParameterNames()</code></td><td>Returns an iterator over names of the parameters
                submitted with the current request.</td></tr><tr><td><code class="literal">String[] getParameterValues(String
                name)</code></td><td>Returns the array of values of the particular parameter
                submitted with the current request.</td></tr><tr><td><code class="literal">String
                getCharacterEncoding()</code></td><td>Returns the character encoding that is used to decode
                the request parameters.</td></tr><tr><td><code class="literal">setCharacterEncoding(String
                encoding)</code></td><td>Sets the character encoding that is used to decode the
                request parameters. Note that this must be called before any
                parameters are read according to the Servlet
                specification.</td></tr><tr><td><code class="literal">String getContentType()</code></td><td>Returns the MIME content type of the request body or
                <code class="literal">null</code> if the body is lacking.</td></tr><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the preferred Locale that the client will
                accept content in, based on the Accept-Language header. If the
                client request doesn't provide an Accept-Language header, this
                method returns the default locale for the server.</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Unlike <code class="literal">InputData</code> methods the parameters are
        presented as is and include both global and scoped parameters (the
        scoped ones are prefixed by the full name of the enclosing
        widget).</p></div><p>However next methods are a bit different from the
      <code class="literal">HttpServletRequest</code> alternatives:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">String getRequestURL()</code></td><td>Returns the target URL of the current request.</td></tr><tr><td><code class="literal">String getContainerURL()</code></td><td>Returns an URL pointing to the Aranea container (in
                most cases the dispatcher servlet).</td></tr><tr><td><code class="literal">String getContextURL()</code></td><td>Returns an URL pointing to the Aranea container context
                (in most cases the web application root).</td></tr><tr><td><code class="literal">String getPath()</code></td><td>Returns the path on the server starting from the
                dispatcher servlet that has been submitted as the part of the
                request target URL.</td></tr><tr><td><code class="literal">pushPathPrefix(String
                pathPrefix)</code></td><td>Consumes the path prefix allowing children to be mapped
                to a relative path.</td></tr><tr><td><code class="literal">popPathPrefix()</code></td><td>Restores the previously consumed path prefix.</td></tr></tbody></table></div><p>The interesting part here are the methods that deal with the path.
      The problem is that unlike most common cases Aranea components form a
      hierarchy. Therefore if a parent is mapped to path prefix "myPath/*" and
      its child is mapped to a path prefix "myChildPath/*" if the path
      handling were absolute the child would never get the mapped calls. This
      is due to the child being really mapped to the path
      "myPath/myChildPath". Therefore the parent must consume the prefix
      "myPath/" using method <code class="literal">pushPathPrefix()</code> and then the
      child will be correctly matched to the relative path
      "myChildPath".</p><p><code class="literal">HttpOutputData</code> contains methods that are
      comparable to the ones found in
      <code class="literal">HttpServletResponse</code>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">String encodeURL(String url)</code></td><td>Encodes the URL to include some additional information
                (e.g. HTTP session identifier). Note that Aranea may include
                some information not present in the servlet spec.</td></tr><tr><td><code class="literal">sendRedirect(String
                location)</code></td><td>Sends an HTTP redirect to a specified location
                URL.</td></tr><tr><td><code class="literal">OutputStream
                getOutputStream()</code></td><td>Returns an <code class="literal">OutputStream</code> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</td></tr><tr><td><code class="literal">PrintWriter getWriter()</code></td><td>Returns a <code class="literal">PrintWriter</code> that can be
                used to write to response. Note that unlike the Servlet
                specification, Aranea permits to use stream and writer
                interchangeably.</td></tr><tr><td><code class="literal">setContentType(String type)</code></td><td>Sets the MIME content type of the output. May include
                the charset, e.g. "text/html; charset=UTF-8".</td></tr><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the locale associated with the
                response.</td></tr><tr><td><code class="literal">String
                getCharacterEncoding()</code></td><td>Returns the character encoding used to write out the
                response.</td></tr><tr><td><code class="literal">void setCharacterEncoding(String
                encoding)</code></td><td>Sets the character encoding used to write out the
                response.</td></tr></tbody></table></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-services"></a>2.5.&nbsp;Services</h2></div></div></div><p><code class="literal">org.araneaframework.Service</code> is a basic
    abstraction over an event-driven <span class="emphasis"><em>Controller</em></span> pattern
    that inherits life cycle, environment and messaging from the
    <code class="literal">Component</code>. The difference from the
    <code class="literal">Component</code> is as follows: </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Service <span class="syntax6">extends</span> Component, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getService</span>();

  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(Path path, InputData input, OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>The method <code class="literal">action()</code> is similar to the
    <code class="literal">service()</code> method in the Servlet API,
    <code class="literal">InputData</code> being an abstraction over a request and
    <code class="literal">OutputData</code> being an abstraction over a response (see
    <a href="core.html#core-io-data" title="2.4.&nbsp;InputData and OutputData">Section&nbsp;2.4, &#8220;InputData and OutputData&#8221;</a>). Thus a service will both process the
    request parameters and render itself during this method call. However
    unlike servlets services can be <span class="emphasis"><em>Composite</em></span> and may be
    defined both statically (on application startup) or dynamically
    (adding/removing new services on the fly).</p><p>Services are the basic working horses of the Aranea framework. They
    can generally be both synchronized and unsynchronized depending on the
    context. Services may also have persistent state and their lifetime is
    explicitly managed by their parent (see <a href="core.html#components-persistence" title="2.3.4.&nbsp;State and Synchronization">Section&nbsp;2.3.4, &#8220;State and Synchronization&#8221;</a>). The service life cycle is very
    simple&#8212;as long as the service is live and enabled it can receive
    <code class="literal">action()</code> calls, possibly several at a time.</p><p>Aranea provides a base implementation of the
    <code class="literal">Service</code> &#8212;
    <code class="literal">org.araneaframework.core.BaseService</code> and a base class
    for application development
    <code class="literal">org.araneaframework.core.BaseApplicationService</code>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1028"></a>2.5.1.&nbsp;Filter Services</h3></div></div></div><p>One of the most common ways to use the services is to create a
      filter service, that wraps a child service and provides some additional
      functionality and/or environment entries. To that purpose Aranea
      provides a filter base class &#8212;
      <code class="literal">org.araneaframework.framework.core.BaseFilterService</code>.
      This class implements all of the Service methods, by default just
      delegating them to the corresponding child methods. A common thing to do
      is override the <code class="literal">action()</code> method to add functionality
      and <code class="literal">getChildEnvironment()</code> to add environment entries,
      as shown in the following example:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> StandardSynchronizingFilterService 
  <span class="syntax6">extends</span> BaseFilterService <span class="syntax11">{</span>
  
  <span class="syntax6">protected</span> Environment <span class="syntax9">getChildEnvironment</span>() <span class="syntax11">{</span>
    <span class="syntax6">return</span> <span class="syntax6">new</span> <span class="syntax9">StandardEnvironment</span>(
        <span class="syntax9">getEnvironment</span>(), 
        SynchronizingContext.<span class="syntax8">class</span>, 
        <span class="syntax6">new</span> <span class="syntax9">SynchronizingContext</span>() <span class="syntax11">{}</span>);
  <span class="syntax11">}</span>
  
  <span class="syntax6">protected</span> <span class="syntax6">synchronized</span> <span class="syntax8">void</span> <span class="syntax9">action</span>(
      Path path, 
      InputData input, 
      OutputData output) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax4">super</span>.<span class="syntax9">action</span>(path, input, output);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>More information on services and other components that make up the
      framework can be found in <a href="framework.html" title="Chapter&nbsp;3.&nbsp;Framework and Configuration">Chapter&nbsp;3, <i>Framework and Configuration</i></a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-widgets"></a>2.6.&nbsp;Widgets</h2></div></div></div><p><span class="emphasis"><em>Widget</em></span> is the main abstraction used to program
    applications in Aranea. Widget is specifically any class extending the
    <code class="literal">org.araneaframework.Widget</code> interface and adhering to a
    number of conventions. More generally, widgets are components that
    function both as controllers and GUI elements, and that have the following
    properties: </p><div class="variablelist"><dl><dt><span class="term">Synchronized</span></dt><dd>
             The widget is <span class="emphasis"><em>almost</em></span> always accessed by a single thread, therefore there is rarely 
             any need to think about synchronization. Usually one can assume that there is only one user 
             using the widget at any time and program to service this user without any concern for concurrency.
             There is only one exception to this: one of the default <code class="literal">Widget</code> implementations
             is <code class="literal">BaseApplicationWidget</code> which allows registration of action listeners (see 
             <a href="core.html#actionlisteners" title="2.7.3.&nbsp;Action Listeners">Section&nbsp;2.7.3, &#8220;Action Listeners&#8221;</a>) which can be invoked asynchronously when so desired.
          </dd><dt><span class="term">Stateful</span></dt><dd>
             When programming widgets there is no need to concern oneself with juggling the 

            <code class="literal">HttpSession</code>

             attributes or similar low-level mechanics. Widget state (meaning the class fields) is guaranteed to be preserved as long as the widget is alive. One can just use these fields to save the necessary data without any external state management, thus adhering to the rules of object-oriented encapsulation. 
          </dd></dl></div><p>The latter two properties make widgets ideal for
    programming custom application components.</p><p>Widgets extend services with a request-response cycle:
    </p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Widget <span class="syntax6">extends</span> Service, Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getWidget</span>();
  
  <span class="syntax6">public</span> <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">update</span>(InputData data) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">event</span>(Path path, InputData input) <span class="syntax6">throws</span> Exception;
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">render</span>(OutputData output) <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span> 
<span class="syntax11">}</span>
</span></pre></pre><p>Although widgets extend services, a widget will function during one
    request either as a widget or as a service&#8212;that is if a widget receives an
    <code class="literal">action()</code> call then no other request-response cycle calls can
    occur.</p><p>The widget request-response cycle proceeds as follows: </p><div class="orderedlist"><ol type="1" compact><li><code class="literal">update()</code>

           &#8212;this method is called for all the widgets in the hierarchy. It allows widgets to read the data from request and possibly store some conversation state or at least temporary information to render the next view. 
        </li><li><code class="literal">event()</code>

           &#8212;this method is called on only one widget in the hierarchy. It allows to send events from the user to widgets. The 

          <code class="literal">path</code>

           is used to route the event to the correct widget and is empty when the event is delivered to its endpoint. This method is optional in the widget request-response cycle. 
        </li><li><code class="literal">render()</code>

           &#8212;the way this method is called depends on how widgets are rendered (see 

          <a href="core.html#components-render" title="2.6.1.&nbsp;ViewModel and Rendering">Section&nbsp;2.6.1, &#8220;ViewModel and Rendering&#8221;</a>

           ). It may be called more than once (or not at all) during one request-response cycle. Typically it is called
           once for each widget that has a rendering template defined.
        </li></ol></div><p>Aranea provides a base implementation of the
    <code class="literal">Widget</code>&#8212;<code class="literal">org.araneaframework.core.BaseWidget</code>
    and a base class for application development
    <code class="literal">org.araneaframework.core.BaseApplicationWidget</code>. More on
    the last one can be found in <a href="core.html#core-application-widgets" title="2.7.&nbsp;Application Widgets">Section&nbsp;2.7, &#8220;Application Widgets&#8221;</a>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="components-render"></a>2.6.1.&nbsp;ViewModel and Rendering</h3></div></div></div><p>The default model of both widget and service rendering is that
      they render themselves. However, in most cases the widget might want to
      delegate the rendering to some templating language. In some other cases
      the widget might be rendered externally, without calling
      <code class="literal">render()</code> at all. Further on, we will describe these
      three cases in detail. </p><div class="variablelist"><dl><dt><span class="term">Self-rendering</span></dt><dd>
               In the most basic situation the widget will just use 

              <code class="literal">OutputData</code>

               for rendering by casting it into e.g. 

              <code class="literal">HttpOutputData</code>

               . In such a case the widget will just write out markup and return from the 

              <code class="literal">render()</code>

               method optionally rendering children as well. The data for rendering will be drawn from the widget fields, children and
               widget <code class="literal">Environment</code>.
			</dd><dt><span class="term">Using templates for rendering</span></dt><dd>
               The most common case in application widgets is to delegate rendering to a templating language. A widget may basically choose to render itself in arbitrary templating language as Aranea does not impose any restrictions. In fact, one widget may be rendered with one templating language, while another one with a completely different language. The template can gain access to the widget using the knowledge of the widget's full name (which is gathered in the 

              <code class="literal">OutputData</code>

               scope). It is then possible to acquire the widget View Model, which is a read-only representation of the widget state. For that the widget should implement 

              <code class="literal">org.araneaframework.Viewable</code>

               : 

              <pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Viewable <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> Interface <span class="syntax9">_getViewable</span>();

  <span class="syntax8">interface</span> Interface <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
    <span class="syntax6">public</span> Object <span class="syntax9">getViewModel</span>() <span class="syntax6">throws</span> Exception;
  <span class="syntax11">}</span>  
<span class="syntax11">}</span>
</span></pre></pre>

               View model is put together by the widget being rendered and should contain all the data necessary to render the widget. 
            </dd><dt><span class="term">External rendering</span></dt><dd><p>Finally, a widget <code class="literal">render()</code> method may
              not be called altogether and a <code class="literal">Viewable</code>
              widget may be rendered externally using the available View
              Model. This is the case with some reusable widgets which are
              rendered using e.g. JSP tags.</p></dd></dl></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="core-application-widgets"></a>2.7.&nbsp;Application Widgets</h2></div></div></div><p>This section explains how to program applications using widgets as
    the main abstraction.</p><p>A typical application widget class will extend
    <code class="literal">org.araneaframework.uilib.core.BaseUIWidget</code>. This
    widget represents the usual custom application component that is rendered
    using Aranea custom JSP tags. <code class="literal">BaseUIWidget</code> inherits
    most of its functionality from
    <code class="literal">org.araneaframework.core.BaseApplicationWidget</code> the
    difference between the two being only that <code class="literal">BaseUIWidget</code>
    assumes to be connected with a JSP page (or another templating
    toolkit).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1198"></a>2.7.1.&nbsp;Children Management</h3></div></div></div><p><code class="literal">BaseApplicationWidget</code> provides a number of
      methods for managing child widgets:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax6">abstract</span> <span class="syntax8">class</span> BaseApplicationWidget ... <span class="syntax11">{</span>
  ...
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">addWidget</span>(Object key, Widget child);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">removeWidget</span>(Object key);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">enableWidget</span>(Object key);
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">disableWidget</span>(Object key);
  ...
<span class="syntax11">}</span>
</span></pre></pre><p>As one can see, every added child has an identifier which should
      be unique among its siblings. This identifier is used when rendering and
      sending events to the widget in question, to identify it among its
      peers. Together with widget's parents identifiers this forms a unique identifier (<span class="emphasis"><em>scope</em></span>)
      of widget in the component hierarchy.</p><p>Typically, children are added when created:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addWidget</span>(<span class="syntax3">"myChildWidget"</span>, <span class="syntax6">new</span> <span class="syntax9">MyChildWidget</span>(<span class="syntax3">"String parameter"</span>, <span class="syntax12">1</span>));
</span></pre></pre><p>An added child will be initialized, will receive updates and
      events and may be rendered. A widget can be active only if added to a
      parent. It will live as long as the parent, unless the parent explicitly
      removes it:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">removeWidget</span>(<span class="syntax3">"myChildWidget"</span>);
</span></pre></pre><p>Removing a child widget will destroy it and one should also
      dispose of any references that may be pointing to it, to allow the child
      to be garbage collected.</p><p>A usual idiom is to save a reference to the newly created and
      added child using a parent widget field:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> MyWidget <span class="syntax6">extends</span> BaseUIWidget <span class="syntax11">{</span>
  <span class="syntax6">private</span> MyChildWidget myChildWidget;
  
  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax11">{</span>
    myChildWidget <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">MyWidget</span>(<span class="syntax3">"String parameter"</span>, <span class="syntax12">1</span>);
    <span class="syntax9">addWidget</span>(<span class="syntax3">"myChildWidget"</span>, myChildWidget);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>This allows to call directly child widget methods and does not
      anyhow significantly increase memory usage, so this technique may be
      used everywhere when needed.</p><p>Disabling a child
      (<code class="literal">disableWidget("myChildWidget")</code>) will stop it from
      receiving any events or rendering, but will not destroy it. It can later
      be reenabled by calling
      <code class="literal">enableWidget("myChildWidget")</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="EventListeners"></a>2.7.2.&nbsp;Event Listeners</h3></div></div></div><p>Registering event listeners allows widgets to subscribe to some
      specific user events (widget will receive only events specially sent to
      it). The distinction comes by the "event identifier" that is assigned to
      an event when sending it. The events are handled by the classes
      extending
      <code class="literal">org.araneaframework.core.EventListener</code>:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> EventListener <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, InputData input) <span class="syntax6">throws</span> Exception;
<span class="syntax11">}</span>
</span></pre></pre><p>The event listeners are registered as following:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">EventListener</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, InputData input) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event: "</span> <span class="syntax11">+</span> eventId);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Of course, the event listener does not have to be an anonymous
      class and can just as well be an inner or even a usual public class. A
      standard base implementation
      <code class="literal">org.araneaframework.core.StandardEventListener</code> is
      provided that receives an optional <code class="literal">String</code> event
      parameter:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">StandardEventListener</span>() <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processEvent</span>(Object eventId, String eventParam, InputData input) <span class="syntax6">throws</span> Exception;
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event "</span> <span class="syntax11">+</span> eventId <span class="syntax11">+</span> <span class="syntax3">" with parameter "</span> <span class="syntax11">+</span> parameter);
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre><p>Another useful way to process events is to register a proxy event
      listener
      (<code class="literal">org.araneaframework.core.ProxyEventListener</code>) that
      will proxy the event to a method call, e.g.:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax11">{</span>
  <span class="syntax9">addEventListener</span>(<span class="syntax3">"myEvent"</span>, <span class="syntax6">new</span> <span class="syntax9">ProxyEventListener</span>(<span class="syntax4">this</span>));
<span class="syntax11">}</span>

<span class="syntax1">// This method handles the event that was registered in init().</span>
<span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">handleEventMyEvent</span>(String parameter) <span class="syntax11">{</span>
    log.<span class="syntax9">debug</span>(<span class="syntax3">"Received event myEvent with parameter "</span> <span class="syntax11">+</span> parameter);
<span class="syntax11">}</span>
</span></pre></pre><p>The convention is that the proxy event listener translates an
      event "&lt;event&gt;" into a method call
      <code class="literal">handleEvent&lt;event&gt;</code> making the first letter of
      &lt;event&gt; uppercase. The <code class="literal">"String parameter</code>" is
      optional and can be omitted.</p><p>A useful feature is the method
      <code class="literal">setGlobalEventListener(EventListener listener)</code> that
      allows to register a listener that will receive all events sent to the
      widget. In fact <code class="literal">BaseUIWidget</code> does that by default,
      and typically you will use the individual event listeners only when you
      want to override this default behaviour. This allows to just define
      correct method names (<code class="literal">handleEvent&lt;event&gt;</code>) and
      all events will be translated to the calls to these methods. Certainly
      this can also be cancelled by calling
      <code class="literal">clearGlobalEventListener()</code>, or overridden by adding
      your own global event listener.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="actionlisteners"></a>2.7.3.&nbsp;Action Listeners</h3></div></div></div><p>Registering action listeners allows widgets to subscribe to some
      specific user generated actions. Actions differ from events in that
      widget lifecycle execution for whole component tree is not triggered
      upon request&#8212;actions are just sent to the receiving widget's <span class="emphasis"><em>ActionListener</em></span>, 
      which is SOLELY responsible for generating the whole response. For rich UI components this allows a quick
      conversations with server, without requiring full form submits and generating whole view.
      </p><p>Actions are handled by the classes extending <code class="literal">org.araneaframework.core.ActionListener</code>
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> ActionListener <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">processAction</span>(Object actionId, InputData input, OutputData output) <span class="syntax6">throws</span> Exception;
<span class="syntax11">}</span>
</span></pre></pre><p> and their registration is analogous to event listeners:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">addActionListener</span>(<span class="syntax3">"actionId"</span>, <span class="syntax6">new</span> <span class="syntax9">SomeActionListener</span>());
</span></pre></pre><p>
	</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widgets-environment"></a>2.7.4.&nbsp;Environment</h3></div></div></div><p>Every initialized widget has a reference to
      <code class="literal">org.araneaframework.Environment</code> available through the
      <code class="literal">getEnvironment()</code> method. Environment allows to look
      up framework services (called <span class="emphasis"><em>contexts</em></span>):</p><pre class="programlisting"><pre><span class="syntax0">MessageContext msgCtx <span class="syntax11">=</span> (MessageContext) <span class="syntax9">getEnvironment</span>().<span class="syntax9">getEntry</span>(MessageContext.<span class="syntax8">class</span>);
msgCtx.<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
</span></pre></pre><p>As one can see from the examples, contexts are looked up using
      their interface <code class="literal">Class</code> object as key. All framework
      services in Aranea are accessible only using the environment.</p><p>To find out more about <code class="literal">Environment</code> see <a href="core.html#core-environment" title="2.3.2.&nbsp;Environment">Section&nbsp;2.3.2, &#8220;Environment&#8221;</a></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1344"></a>2.7.5.&nbsp;Overridable Methods</h3></div></div></div><p>The main method that is typically overridden in a widget is
      <code class="literal">init()</code>. As widget does not get an environment before
      it is added and initialized it is impossible to access framework
      services in the constructor, therefore most of the initialization logic
      moves to the custom <code class="literal">init()</code> method. A dual overridable
      method is <code class="literal">destroy()</code>, though it is used much
      less.</p><p>In addition to event processing it is sometimes useful to do some
      kind of preprocessing. The <code class="literal">BaseApplicationWidget</code> has the following method that
      may be overridden to allow this processing:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">handleUpdate</span>(InputData input) <span class="syntax6">throws</span> Exception <span class="syntax11">{}</span>
</span></pre></pre><p><code class="literal">handleUpdate()</code> is called before event listeners
      are notified and allows to read and save request data preparing it for
      the event. More importantly, this method is called even when no event is
      sent to the current widget allowing one to submit some data to any
      widget.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1370"></a>2.7.6.&nbsp;InputData and OuputData</h3></div></div></div><p>In Aranea one usually does not need to handle request manually in
      custom application widgets. Even more, the request is not accessible by
      default. The usual way to submit custom data to a widget and read it is
      using Aranea Forms (see <a href="forms.html" title="Chapter&nbsp;5.&nbsp;Forms and Data Binding">Chapter&nbsp;5, <i>Forms and Data Binding</i></a>). However, when one
      needs to access the submitted data, one can do that using the
      <code class="literal">org.araneaframework.InputData</code>. This class can be used
      as follows: </p><pre class="programlisting"><pre><span class="syntax0">...
String myData1 <span class="syntax11">=</span> 
  (String) <span class="syntax9">getInputData</span>().<span class="syntax9">getScopedData</span>().<span class="syntax9">get</span>(<span class="syntax3">"myData1"</span>);
String globalSubmittedParameter <span class="syntax11">=</span> 
  (String) <span class="syntax9">getInputData</span>().<span class="syntax9">getGlobalData</span>().<span class="syntax9">get</span>(<span class="syntax3">"globalSubmittedParameter"</span>);
...
</span></pre></pre><p> <code class="literal">getInputData()</code> is a
      <code class="literal">BaseApplicationWidget</code> method that returns the input
      data for the current request (one can also use the
      <code class="literal">input</code> parameter given to event listener
      directly).</p><p><code class="literal">org.araneaframework.OutputData</code> is accessible
      through the <code class="literal">getOutputData()</code> method of
      <code class="literal">BaseWidget</code> or directly as the
      <code class="literal">output</code> parameter passed to
      <code class="literal">render()</code> method.</p><p>To find out more about <code class="literal">InputData</code> and
      <code class="literal">OutputData</code> see <a href="core.html#core-io-data" title="2.4.&nbsp;InputData and OutputData">Section&nbsp;2.4, &#8220;InputData and OutputData&#8221;</a></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widget-view-selector"></a>2.7.7.&nbsp;View Model and Rendering</h3></div></div></div><p><code class="literal">BaseApplicationWidget</code> also contains methods
      that facilitate transferring data to the presentation layer. This is
      achieved using a <span class="emphasis"><em>View model</em></span>&#8212;an object containing a
      snapshot of the widget current state. The most typical way to use the
      view model it to add data to it:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">putViewData</span>(<span class="syntax3">"today"</span>, <span class="syntax6">new</span> <span class="syntax9">Date</span>());
<span class="syntax9">putViewData</span>(<span class="syntax3">"currentUser"</span>, userBean);
...
</span></pre></pre><p>View data is typically accessible in the presentation layer as
      some kind of a variable (e.g. a JSP EL variable) for the current widget.
      If the data becomes outdated one can override it using
      <code class="literal">putViewData()</code> call or remove it using the
      <code class="literal">removeViewData()</code> call. In case one needs to put view
      data that would last one request only there is an alternative
      method:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">putViewDataOnce</span>(<span class="syntax3">"now"</span>, <span class="syntax6">new</span> <span class="syntax9">Date</span>());
...
</span></pre></pre><p>Finally widget instance is also visible to the view, so one of the
      ways to make some data accessible is just to define a JavaBean style
      getter:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax6">public</span> Date <span class="syntax9">getNow</span>() <span class="syntax11">{</span>
  <span class="syntax6">return</span> <span class="syntax6">new</span> <span class="syntax9">Date</span>();
<span class="syntax11">}</span>
...
</span></pre></pre><p><code class="literal">BaseUIWidget</code> allows to render the
      current widget using a JSP page. To do that one needs to select a view
      as follows:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">setViewSelector</span>(<span class="syntax3">"myWidget/form"</span>);
...
</span></pre></pre><p>This code makes the widget render itself using the JSP situated in
      <code class="literal">WEB-INF/jsp/myWidget/form.jsp</code> (of course the exact
      place is configurable). It is also possible to render the widget using
      other template technologies with the same view selector by overriding
      the <code class="literal">render()</code> method in the base project
      widget.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="widgets-example-widget"></a>2.7.8.&nbsp;Putting It All Together</h3></div></div></div><p>A typical application custom widget will look like that:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> TestWidget <span class="syntax6">extends</span> BaseUIWidget <span class="syntax11">{</span>

  <span class="syntax6">private</span> <span class="syntax6">static</span> <span class="syntax6">final</span> Logger log <span class="syntax11">=</span> Logger.<span class="syntax9">getLogger</span>(TestWidget.<span class="syntax8">class</span>);
  
  <span class="syntax6">private</span> Data data;
  
  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax1">//Sets the JSP for this widget to "/WEB-INF/jsp/home.jsp"</span>
    <span class="syntax9">setViewSelector</span>(<span class="syntax3">"home"</span>);
    
    <span class="syntax1">//Get data from the business layer</span>
    data <span class="syntax11">=</span> ((TestService) <span class="syntax9">lookupService</span>(<span class="syntax3">"testService"</span>)).<span class="syntax9">getData</span>(<span class="syntax3">"test parameter"</span>);
    
    <span class="syntax1">//Make the data accessible to the JSP for rendering</span>
    <span class="syntax9">putViewData</span>(<span class="syntax3">"myData"</span>, data);    
  <span class="syntax11">}</span>
  
  <span class="syntax1">/*</span>
<span class="syntax1">   * Event listener method that will process "test" event.</span>
<span class="syntax1">   */</span>
  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">handleEventTest</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Test event received successfully"</span>);       
  <span class="syntax11">}</span>
<span class="syntax11">}</span>
</span></pre></pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1468"></a>2.8.&nbsp;Standard Contexts</h2></div></div></div><p>Contexts are the Aranea way to access framework services. They can
    be looked up from the environment as shown in <a href="core.html#widgets-environment" title="2.7.4.&nbsp;Environment">Section&nbsp;2.7.4, &#8220;Environment&#8221;</a>. This section describes the most common
    Aranea contexts that should be available in any typical configuration. All
    these contexts are also available directly through
    <code class="literal">BaseUIWidget</code> methods as shown further on.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="MessageContext"></a>2.8.1.&nbsp;MessageContext</h3></div></div></div><p><code class="literal">org.araneaframework.framework.MessageContext</code>
      allows to show messages to the user. The messages can be of several
      types, including predefined error and informative types. Typically
      messages will be shown somewhere in the application (exact way is
      application-specific). <code class="literal">MessageContext</code> is available
      through a <code class="literal">BaseUIWidget</code> method
      <code class="literal">getMessageCtx()</code> and is typically used as
      follows:</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"Hello world!"</span>);
</span></pre></pre><p><code class="literal">MessageContext</code> divides messages by type (with
      predefined "info", "warning" and "error" types available) and life span
      (usual or permanent). Usual messages are shown to user once and then
      cleared, while permanent messages will be shown to user until explicitly
      cleared by the programmer:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">showMessage(String type, String
                message)</code></td><td>Shows a message <code class="literal">message</code> of type
                <code class="literal">type</code> to the user.</td></tr><tr><td><code class="literal">showMessages(String type, Set&lt;String&gt; messages)</code></td><td>Shows messages of type <code class="literal">type</code> to the user.</td></tr><tr><td><code class="literal">showInfoMessage(String
                message)</code></td><td>Shows an error message to the user.</td></tr><tr><td><code class="literal">hideInfoMessage(String
                message)</code></td><td>Hides an info message from user.</td></tr><tr><td><code class="literal">showWarningMessage(String
                message)</code></td><td>Shows a warning message to the user.</td></tr><tr><td><code class="literal">hideWarningMessage(String message)</code></td><td>Hides a warning message from user.</td></tr><tr><td><code class="literal">showErrorMessage(String
                message)</code></td><td>Shows an informative message to the user.</td></tr><tr><td><code class="literal">hideErrorMessage(String message)</code></td><td>Hides an error message from user.</td></tr><tr><td><code class="literal">clearMessages()</code></td><td>Clears all non-permanent messages.</td></tr><tr><td><code class="literal">showPermanentMessage(String type, String
                message)</code></td><td>Shows a permanent message <code class="literal">message</code> of
                type <code class="literal">type</code> to the user. The message will be
                shown until hidden explicitly.</td></tr><tr><td><code class="literal">hideMessage(String type, String message);</code></td><td>Removes a message <code class="literal">message</code> of type <code class="literal">type</code>.</td></tr><tr><td><code class="literal">hideMessages(String type, Set&lt;String&gt; messages);</code></td><td>Removes messages of type <code class="literal">type</code>.</td></tr><tr><td><code class="literal">hidePermanentMessage(String
                message)</code></td><td>Clears the specific permanent message, under all
                message types where it might be present.</td></tr><tr><td><code class="literal">clearPermanentMessages()</code></td><td>Clears all of the permanent messages.</td></tr><tr><td><code class="literal">clearAllMessages()</code></td><td>Clears all messages (both permanent and usual).</td></tr><tr><td><code class="literal">Map&lt;String, Collection&gt; getMessages()</code></td><td>Returns all present messages as a Map. Keys of the Map are the different message types encountered so far and under the keys 
                are the messages in a Collection.</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Messages should already be localized when passed to the
        <code class="literal">MessageContext</code>, it does not do any further
        processing. Use <code class="literal">LocalizationContext</code> described in
        <a href="core.html#LocalizationContext" title="2.8.2.&nbsp;LocalizationContext">Section&nbsp;2.8.2, &#8220;LocalizationContext&#8221;</a> to do the actual localization
        of the added message.</p></div><p>For information on implementation of the
      <code class="literal">MessageContext</code> see <a href="framework.html#araneaMessagingFilter" title="3.5.8.&nbsp;User Messages Filter">Section&nbsp;3.5.8, &#8220;User Messages Filter&#8221;</a>. For standard JSP tag which renders <code class="literal">MessageContext</code>
      messages to response, see <a href="jsp.html#uimessagesjsp">&lt;ui:messages&gt;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="LocalizationContext"></a>2.8.2.&nbsp;LocalizationContext</h3></div></div></div><p><code class="literal">org.araneaframework.framework.LocalizationContext</code>
      allows to get and set current session locale, localize strings and
      messages, and lookup resource bundles. The context is available through
      the <code class="literal">BaseUIWidget</code> method
      <code class="literal">getL10nCtx()</code>. Typically it is used as follows:</p><pre class="programlisting"><pre><span class="syntax0">
...
String message <span class="syntax11">=</span> <span class="syntax9">getL10nCtx</span>().<span class="syntax9">localize</span>(<span class="syntax3">"my.message.key"</span>);
<span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(message);
...
</span></pre></pre><p><code class="literal">LocalizationContext</code> provides the following
      methods:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">Locale getLocale()</code></td><td>Returns the current session locale.</td></tr><tr><td><code class="literal">setLocale(Locale locale)</code></td><td>Sets the current session locale.</td></tr><tr><td><code class="literal">String localize(String key)</code></td><td>Localizes a string returning one that corresponds to
                the current locale.</td></tr><tr><td><code class="literal">ResourceBundle
                getResourceBundle()</code></td><td>Returns a resource bundle corresponding to the current
                locale.</td></tr><tr><td><code class="literal">ResourceBundle getResourceBundle(Locale
                locale)</code></td><td>Returns a resource bundle corresponding to arbitrary
                locale.</td></tr><tr><td><code class="literal">String getMessage(String code, Object[]
                args)</code></td><td>Localizes the code and uses it to format the message
                with the passed arguments. The format of the localized message
                should be acceptable by
                <code class="literal">java.text.MessageFormat</code>.</td></tr><tr><td><code class="literal">String getMessage(String code, Object[] args,
                String defaultMessage)</code></td><td>Localizes the code and uses it to format the message
                with the passed arguments. The format of the localized message
                should be acceptable by
                <code class="literal">java.text.MessageFormat</code>. If the localized
                message cannot be resolved uses
                <code class="literal">defaultMessage</code> instead.</td></tr><tr><td><code class="literal">void addLocaleChangeListener(LocaleChangeListener listener);</code></td><td>Registers a listener (<code class="literal">Component</code>) that will be notified when locale is changed.</td></tr><tr><td><code class="literal">boolean removeLocaleChangeListener(LocaleChangeListener listener)</code></td><td>Unregisters listener (<code class="literal">Component</code>) so that it will not be notified of locale changes anymore. Returns
                whether the listener was found to be present and actually removed.</td></tr></tbody></table></div><p>For information on implementation of the
      <code class="literal">LocalizationContext</code> see <a href="integration.html#araneaLocalizationFilter" title="8.1.2.&nbsp;Spring Localization Filter">Section&nbsp;8.1.2, &#8220;Spring Localization Filter&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="FlowContext"></a>2.8.3.&nbsp;FlowContext</h3></div></div></div><p>A common need in a web programming is to support navigation style
      known as <span class="emphasis"><em>flows</em></span>&#8212;interactive stateful processes that
      can navigate to each other passing arguments when needed. A more complex
      case is when we also have flow nesting&#8212;a flow can call a subflow, and
      wait for it to finish, then reactivate again. In this case we can have
      at any given moment a stack of flows, where the top one is active, and
      the next one will reactivate when the top one finishes. It is also
      useful if nested flows can return resulting values when they
      finish.</p><div class="figure"><a name="d0e1774"></a><div class="mediaobject"><img src="../images/flows.png" alt="Flow diagram"></div><p class="title"><b>Figure&nbsp;2.2.&nbsp;Flow diagram</b></p></div><p><code class="literal">org.araneaframework.framework.FlowContext</code> is
      the Aranea context that provides support for nested flow navigation.
      Aranea flow is a widget that is running in the flow container (using the
      <code class="literal">FlowContext.start()</code> method. Aranea abstraction for
      the nested state is that of a function&#8212;the nested
      <span class="emphasis"><em>flow</em></span> takes in some parameters and when finished may
      return some value or signal that no value can be returned. The context
      is available as <code class="literal">getFlowCtx()</code> method of
      <code class="literal">BaseUIWidget</code> and allows to start flows, finish flows
      and return the resulting value.</p><p>To start a new flow one needs to create a widget as usual. The
      widget may take some parameters in the constructor&#8212;they are considered
      to be the incoming parameters of the flow:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)));
...
</span></pre></pre><p>This call will start a new nested flow for the widget
      <code class="literal">TestFlow</code> making the current flow inactive.
      <code class="literal">TestFlow</code> will render and receive event until it
      explicitly returns control to the starting flow. Note that this code
      will start the flow and then return the control, so it is important not
      to do anything in the same method after starting a new flow.</p><p>To end the flow successfully one needs to do as follows:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">finish</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">8</span>));
...
</span></pre></pre><p>This call will finish the current flow (in our case
      <code class="literal">TestFlow</code>) and return the control to the starting flow
      and its widget.</p><p>Often one needs to handle the return from the flow, processing the
      returned result. This corresponds to our abstraction of a method,
      however since Java does not support continuations we chose to allow the
      caller to register a handler when starting the flow by passing a
      <code class="literal">FlowContext.Handler</code>:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)),
  <span class="syntax6">new</span> FlowContext.<span class="syntax9">Handler</span>() <span class="syntax11">{</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">onFinish</span>(Object result) <span class="syntax11">{</span>
      <span class="syntax9">getMessageCtx</span>().<span class="syntax9">showInfoMessage</span>(<span class="syntax3">"TestFlow returned value "</span> <span class="syntax11">+</span> result);
    <span class="syntax11">}</span>
    <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">onCancel</span>() <span class="syntax11">{</span>
      <span class="syntax1">//Ignore cancelled flow</span>
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>);
...
</span></pre></pre><p></p><p>A less common but nevertheless useful feature is to configure the
      starting flow after it has been initialized. For that the caller needs
      to pass a <code class="literal">FlowContext.Configurator</code>:</p><pre class="programlisting"><pre><span class="syntax0">...
<span class="syntax9">getFlowCtx</span>().<span class="syntax9">start</span>(<span class="syntax6">new</span> <span class="syntax9">TestFlow</span>(<span class="syntax6">new</span> <span class="syntax9">Long</span>(<span class="syntax12">5</span>)), 
  <span class="syntax6">new</span> FlowContext.<span class="syntax9">Configurator</span>() <span class="syntax11">{</span>
     <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">configure</span>(Component comp) <span class="syntax11">{</span>
      ((TestFlow) comp).<span class="syntax9">setStrategy</span>(TestFlow.ATTACK);
     <span class="syntax11">}</span>
  <span class="syntax11">}</span>, <span class="syntax4">null</span>);
...
</span></pre></pre><p></p><p><code class="literal">FlowContext</code> also allows to replace the
      current flow instead of deactivating it by using the
      <code class="literal">replace()</code> method and to cancel the current flow by
      using the <code class="literal">cancel()</code> method.</p><p>
      	Transitions between the flows are performed by <code class="literal">FlowContext.TransitionHandler</code>s.
      	
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax8">interface</span> TransitionHandler <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>
   <span class="syntax2">/**</span>
<span class="syntax2">    * </span><span class="syntax5">@param</span><span class="syntax2"> eventType FlowContext.START .. FlowContext.RESET</span>
<span class="syntax2">    * </span><span class="syntax5">@param</span><span class="syntax2"> activeFlow active flow at the moment of transition request</span>
<span class="syntax2">    * </span><span class="syntax5">@param</span><span class="syntax2"> transition Serializable closure that needs to be executed for transition to happen</span>
<span class="syntax2">    </span><span class="syntax2">*/</span>
   <span class="syntax8">void</span> <span class="syntax9">doTransition</span>(<span class="syntax8">int</span> eventType, Widget activeFlow, Closure transition);
<span class="syntax11">}</span>
</span></pre></pre><p>
      </p><p>
        After initialization, each flow may set the <code class="literal">TransitionHandler</code> which will
        handle navigation events performed while flow which set the <code class="literal">TransitionHandler</code> 
        is active. This can be used to customize navigation logic&#8212;i.e. ask for confirmations 
        when navigating away from flow containing unsaved data, restore window scroll position when
        returning to caller flow or checking for privileges before starting the next flow.
      </p><p>For standard implementation, please see <a href="framework.html#araneaRootFlowContainer" title="3.5.18.&nbsp;Root Flow Container">Section&nbsp;3.5.18, &#8220;Root Flow Container&#8221;</a></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="PopupWindowContext"></a>2.8.4.&nbsp;PopupWindowContext</h3></div></div></div><p>
			Popup windows in Aranea are separate threads that are started using
			<code class="literal">org.araneaframework.http.PopupWindowContext</code>. Popups can
			be used, for example, to open new widgets or to upload files (using
			<code class="literal">org.araneaframework.http.service.FileDownloaderService</code>).
			To open a new widget in a popup, the widget must handle the entire page,
			and its subwidgets may handle certain specific parts of a page. This is
			similar to how a root widget handles the components in the main thread.
			</p><p>
			One can access the <code class="literal">PopupWindowContext</code> by getting it from
			the <code class="literal">Environment</code>. If it is accessed from a widget that extends
			<code class="literal">BaseUIWidget</code>, the <code class="literal">getPopupCtx()</code> method can
			be used.
			</p><p>
			Here is an example on how to the server enables the user to download a file:

</p><pre class="programlisting"><pre><span class="syntax0">  PopupWindowContext popupContext <span class="syntax11">=</span> (PopupWindowContext) <span class="syntax9">getEnvironment</span>().<span class="syntax9">getEntry</span>(PopupWindowContext.<span class="syntax8">class</span>);
  popupContext.<span class="syntax9">open</span>(<span class="syntax6">new</span> <span class="syntax9">FileDownloaderService</span>(selectedFile), <span class="syntax6">new</span> <span class="syntax9">PopupWindowProperties</span>(), <span class="syntax4">null</span>);
</span></pre></pre><p>

			In the example above, the first parameter is the service that downloads the file
			to the user's computer, and the second one is the popup window properties. Sometimes 
			one may want to also specify the widget that caused the popup to open.
			Therefore, the last parameter in the example is the opener, which usually is
			<code class="literal">null</code>, but may be provided as <code class="literal">this</code> (the caller widget).
			(The popup widget can access the opener by <code class="literal">PopupWindowContext.getOpener()</code>.)
			</p><p>
			The following is an example from Aranea sample application (<code class="literal">SamplePopupWidget</code>)
			on how to open a popup widget (from a widget that extends <code class="literal">BaseUIWidget</code>):

</p><pre class="programlisting"><pre><span class="syntax0">  <span class="syntax9">getPopupCtx</span>().<span class="syntax9">open</span>(
    <span class="syntax6">new</span> <span class="syntax9">LoginAndMenuSelectMessage</span>(<span class="syntax3">"Demos.Simple.Simple_Form"</span>), 
    <span class="syntax6">new</span> <span class="syntax9">PopupWindowProperties</span>(), <span class="syntax4">this</span>);
</span></pre></pre><p>

			Here it must send a <code class="literal">Message</code> to the components that starts
			new widgets to produce the desired effect. The <code class="literal">LoginAndMenuSelectMessage</code>
			is a <code class="literal">SeriesMessage</code> that first uses the flow context from the
			child environment of the login widget to start a new root context. Then the menu select
			widget searches the menu widget to select the given menu item. Below  are the codes
			for messages.
			</p><p>
			The code for the <code class="literal">LoginAndMenuSelectMessage</code>:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> LoginAndMenuSelectMessage <span class="syntax6">extends</span> SeriesMessage <span class="syntax11">{</span>

  <span class="syntax6">public</span> <span class="syntax9">LoginAndMenuSelectMessage</span>(String menuPath) <span class="syntax11">{</span>
    <span class="syntax4">super</span>(<span class="syntax6">new</span> Message[] <span class="syntax11">{</span>
        <span class="syntax6">new</span> <span class="syntax9">LoginMessage</span>(), 
        <span class="syntax6">new</span> <span class="syntax9">MenuSelectMessage</span>(menuPath)<span class="syntax11">}</span>);
  <span class="syntax11">}</span>

<span class="syntax11">}</span>
</span></pre></pre><p>
			</p><p>
			The code for the <code class="literal">LoginMessage</code>:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> LoginMessage <span class="syntax6">extends</span> BroadcastMessage <span class="syntax11">{</span>

  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> LoginWidget) <span class="syntax11">{</span>
      LoginWidget loginWidget <span class="syntax11">=</span> (LoginWidget) component;

      Environment childEnv <span class="syntax11">=</span> loginWidget.<span class="syntax9">getChildEnvironment</span>();

      FlowContext flow <span class="syntax11">=</span> (FlowContext) childEnv.<span class="syntax9">getEntry</span>(FlowContext.<span class="syntax8">class</span>);
      flow.<span class="syntax9">replace</span>(<span class="syntax6">new</span> <span class="syntax9">RootWidget</span>(), <span class="syntax4">null</span>);
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>

<span class="syntax11">}</span>
</span></pre></pre><p>
			</p><p>
			The code for the <code class="literal">MenuSelectMessage</code>:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> MenuSelectMessage <span class="syntax6">extends</span> BroadcastMessage <span class="syntax11">{</span>

  <span class="syntax6">private</span> String menuPath;

  <span class="syntax6">public</span> <span class="syntax9">MenuSelectMessage</span>(String menuPath) <span class="syntax11">{</span>
    <span class="syntax4">this</span>.menuPath <span class="syntax11">=</span> menuPath;
  <span class="syntax11">}</span>

  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(Component component) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    <span class="syntax6">if</span> (component <span class="syntax6">instanceof</span> MenuWidget) <span class="syntax11">{</span>
      MenuWidget w <span class="syntax11">=</span> (MenuWidget) component;
      w.<span class="syntax9">selectMenuItem</span>(menuPath);
    <span class="syntax11">}</span>
  <span class="syntax11">}</span>

<span class="syntax11">}</span>
</span></pre></pre><p>
			</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">String open(Message startMessage, PopupWindowProperties properties, Widget opener)</code></td><td>Uses a message that opens a widget inside a new popup.</td></tr><tr><td><code class="literal">String open(Service service, PopupWindowProperties properties, Widget opener)</code></td><td>Uses a service that serves the data for a new popup.</td></tr><tr><td><code class="literal">String openMounted(String url, PopupWindowProperties properties)</code></td><td>Opens the mount URL in a popup.</td></tr><tr><td><code class="literal">open(String url, PopupWindowProperties properties)</code></td><td>Opens the given URL in a popup.</td></tr><tr><td><code class="literal">boolean close(String id) throws Exception</code></td><td>Closes the popup with given ID (the ID is returend when the popup is created).</td></tr><tr><td><code class="literal">Widget getOpener()</code></td><td>Provides the popup opener.</td></tr><tr><td><code class="literal">Map getPopups()</code></td><td>Returns a map with popups (the key is the ID of the popup, and
                the value is an instance of <code class="literal">PopupServiceInfo</code>.</td></tr></tbody></table></div><p>
      </p><p>
			To enable popups at JSP layer, one must also register it inside the system form as
			the following code snippet does from <code class="literal">root.jsp</code> of the Aranea Demo Application:

</p><pre class="programlisting"><pre><span class="syntax0">...
  <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">body</span><span class="syntax10">&gt;</span>

    <span class="syntax10">&lt;</span><span class="syntax10">div id</span>=<span class="syntax3">"</span><span class="syntax3">cont1</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
      <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">systemForm</span><span class="syntax10"> method</span>=<span class="syntax3">"</span><span class="syntax3">POST</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
        <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">register...</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
        <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">registerPopups</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
...
</span></pre></pre><p>
			</p><p>
        Standard implementation of <code class="literal">PopupWindowContext</code> is described in
        <a href="framework.html#araneaPopupFilter" title="3.5.9.&nbsp;Popup Windows Filter">Section&nbsp;3.5.9, &#8220;Popup Windows Filter&#8221;</a>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="OverlayContext"></a>2.8.5.&nbsp;OverlayContext</h3></div></div></div><p>
			Supports running processes in "overlay" (in parallel <code class="literal">FlowContext</code>
			of the same session thread). It is used to allow construction of modal dialogs and modal processes.
			To start a process inside overlay, a widget calls one of the
			<code class="literal">getOverlayCtx().start(...)</code> methods.
			</p><p>
			The <code class="literal">getOverlayCtx()</code> method is defined in
			<code class="literal">BaseUIWidget</code> so all sub-classes should be able to access it.
			Others can retrieve it from the <code class="literal">Environment</code> like following:
			<code class="literal">(OverlayContext) getEnvironment().getEntry(OverlayContext.class)</code>.
			</p><p>
			The first time the overlay mode is started, the <code class="literal">start(...)</code> must take
			a container (root) widget as its argument because everything that happens in overlay mode,
			is happening like in a separate window. For example, the code in Aranea Demo Application
			creates the overlay root widget and its content(s) like this:

			</p><pre class="programlisting"><pre><span class="syntax0">  <span class="syntax9">getOverlayCtx</span>().<span class="syntax9">start</span>(
      <span class="syntax6">new</span> <span class="syntax9">OverlayRootWidget</span>(<span class="syntax6">new</span> <span class="syntax9">ModalDialogDemoWidget</span>(<span class="syntax4">true</span>)));
</span></pre></pre><p>

			Notice that the <code class="literal">start(...)</code> method is used to start two widgets.
			The custom-made <code class="literal">OverlayRootWidget</code> acts like a root widget, which
			behind the scenes also specifies a flow container for the child widget
			(i.e. ModalDialogDemoWidget). Here is the sample code for the OverlayRootWidget: 

</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">class</span> OverlayRootWidget <span class="syntax6">extends</span> BaseUIWidget <span class="syntax11">{</span>

  <span class="syntax6">private</span> Widget child;

  <span class="syntax6">public</span> <span class="syntax9">OverlayRootWidget</span>(Widget child) <span class="syntax11">{</span>
    <span class="syntax4">this</span>.child <span class="syntax11">=</span> child;
  <span class="syntax11">}</span>

  <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">init</span>() <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
    Assert.<span class="syntax9">notNull</span>(child);
    <span class="syntax9">addWidget</span>(<span class="syntax3">"c"</span>, <span class="syntax6">new</span> <span class="syntax9">OverlayFlowContainer</span>(child));
    <span class="syntax9">setViewSelector</span>(<span class="syntax3">"overlayRoot"</span>);
  <span class="syntax11">}</span>

  <span class="syntax6">private</span> <span class="syntax8">class</span> OverlayFlowContainer <span class="syntax6">extends</span> ExceptionHandlingFlowContainerWidget <span class="syntax11">{</span>

    <span class="syntax6">public</span> <span class="syntax9">OverlayFlowContainer</span>(Widget topWidget) <span class="syntax11">{</span>
        <span class="syntax4">super</span>(topWidget);
    <span class="syntax11">}</span>

    <span class="syntax6">protected</span> <span class="syntax8">void</span> <span class="syntax9">renderExceptionHandler</span>(OutputData output, Exception e) <span class="syntax6">throws</span> Exception <span class="syntax11">{</span>
      <span class="syntax6">if</span> (ExceptionUtils.<span class="syntax9">getRootCause</span>(e) <span class="syntax11">!=</span> <span class="syntax4">null</span>) <span class="syntax11">{</span>
        <span class="syntax9">putViewDataOnce</span>(<span class="syntax3">"rootStackTrace"</span>, ExceptionUtils.<span class="syntax9">getFullStackTrace</span>(
            ExceptionUtils.<span class="syntax9">getRootCause</span>(e)));
      <span class="syntax11">}</span>        
      <span class="syntax9">putViewDataOnce</span>(<span class="syntax3">"fullStackTrace"</span>, ExceptionUtils.<span class="syntax9">getFullStackTrace</span>(e)); 
      ServletUtil.<span class="syntax9">include</span>(<span class="syntax3">"/WEB-INF/jsp/menuError.jsp"</span>, <span class="syntax4">this</span>, output);
    <span class="syntax11">}</span>

  <span class="syntax11">}</span>

<span class="syntax11">}</span>
</span></pre></pre><p>

			</p><p>
			<code class="literal">OverlayContext</code> provides the <code class="literal">replace*</code>, <code class="literal">start*</code> and <code class="literal">reset*</code>
      methods that act analogously to <code class="literal">FlowContext</code> corresponding methods, but affect only overlayed 
      process. Additionally, following methods are available:
      </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">boolean isOverlayActive()</code></td><td>Returns whether some overlayed process is active.</td></tr><tr><td><code class="literal">setOverlayOptions(Map options)</code></td><td>Sets the presentation options for overlayed processes.</td></tr><tr><td><code class="literal">Map getOverlayOptions()</code></td><td>Returns the map with current presentation options for overlayed processes.</td></tr><tr><td><code class="literal">finish(Object result)</code></td><td>Similar to <code class="literal">FlowContext.finish(Object obj)</code> but closes the entire
                <code class="literal">OverlayContext</code> not just the last flow widget.</td></tr><tr><td><code class="literal">cancel()</code></td><td>Similar to <code class="literal">FlowContext.cancel()</code> but closes the entire
                <code class="literal">OverlayContext</code> not just the last flow widget.</td></tr></tbody></table></div><p>
      </p><p>
			To make overlay possible on the client-side, one must register it inside the system
			form as the following code snippet does from <code class="literal">root.jsp</code> of the
			Aranea Demo Application. In addition, the modalbox.css file must also be incorporated
			to enable the visual part of the overlay mode. In the example below, the file is
			explicitly defined (it refers to the modalbox.css provided by Aranea), although the
			necessary styles are also included if there are no attributes specified on the tag.
			

			</p><pre class="programlisting"><pre><span class="syntax0">  ...
  <span class="syntax10">&lt;</span><span class="syntax10">head</span><span class="syntax10">&gt;</span>
        ...
        <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">importStyles</span><span class="syntax10"> file</span>=<span class="syntax3">"</span><span class="syntax3">css/modalbox/modalbox.css</span><span class="syntax3">"</span><span class="syntax10"> media</span>=<span class="syntax3">"</span><span class="syntax3">screen</span><span class="syntax3">"</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
        ...
  <span class="syntax10">&lt;</span><span class="syntax10">/head</span><span class="syntax10">&gt;</span>

  <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">body</span><span class="syntax10">&gt;</span>

    <span class="syntax10">&lt;</span><span class="syntax10">div id</span>=<span class="syntax3">"</span><span class="syntax3">cont1</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
      <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">systemForm</span><span class="syntax10"> method</span>=<span class="syntax3">"</span><span class="syntax3">POST</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
        <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">register...</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
        <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">registerOverlay</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
...
</span></pre></pre><p>

			Notice the <code class="literal">&lt;ui:registerOverlay/&gt;</code> tag!
			</p><p>
        Standard implementation of <code class="literal">OverlayContext</code> is described in
        <a href="framework.html#StandardOverlayContainerWidget" title="3.5.19.&nbsp;Overlay Container">Section&nbsp;3.5.19, &#8220;Overlay Container&#8221;</a>.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="MenuContext"></a>2.8.6.&nbsp;MenuContext</h3></div></div></div><p>
			Defines the standard methods for menu handlers (contexts). Most custom implementations
			can extend the <code class="literal">org.araneaframework.uilib.core.BaseMenuWidget</code> and
			its <code class="literal">buildMenu()</code> method.
			</p><p>
      	</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Method</th><th align="left">Description</th></tr></thead><tbody><tr><td><code class="literal">void selectMenuItem(String menuItemPath)</code></td><td>Marks the menu item (identified by given path) as active.</td></tr><tr><td><code class="literal">MenuItem getMenu()</code></td><td>Provides access to the entire menu.</td></tr><tr><td><code class="literal">void setMenu(MenuItem menu)</code></td><td>Specifies the menu to use.</td></tr></tbody></table></div><p>
      </p><p>
			All menu items are represented as a tree of
			<code class="literal">org.araneaframework.uilib.core.MenuItem</code> objects that
			have its own label and a flow (a widget or a flow creator). An entire menu is also
			a <code class="literal">MenuItem</code> and its menus are declared with
			<code class="literal">addSubMenuItem(MenuItem item)</code>. A <code class="literal">MenuItem</code>
			may not have a flow, if it represents a sub menu. An example menu might look like this:

</p><pre class="programlisting"><pre><span class="syntax0">  MenuItem menu <span class="syntax11">=</span> <span class="syntax6">new</span> <span class="syntax9">MenuItem</span>();
  demoMenu <span class="syntax11">=</span> menu.<span class="syntax9">addMenuItem</span>(<span class="syntax4">null</span>, <span class="syntax6">new</span> <span class="syntax9">MenuItem</span>(<span class="syntax3">"Demo_Menu"</span>, DemoWidget.<span class="syntax8">class</span>));
  demoMenu.<span class="syntax9">addMenuItem</span>(<span class="syntax6">new</span> <span class="syntax9">MenuItem</span>(<span class="syntax3">"Context_Menus"</span>, DemoContextMenuWidget.<span class="syntax8">class</span>));
  demoMenu.<span class="syntax9">addMenuItem</span>(<span class="syntax6">new</span> <span class="syntax9">MenuItem</span>(<span class="syntax3">"Easy_AJAX_Update_Regions"</span>, EasyAJAXUpdateRegionsWidget.<span class="syntax8">class</span>));
  demoMenu.<span class="syntax9">addMenuItem</span>(<span class="syntax6">new</span> <span class="syntax9">MenuItem</span>(<span class="syntax3">"Cooperative_Form"</span>, FriendlyUpdateDemoWidget.<span class="syntax8">class</span>));
  ...
</span></pre></pre><p>
			</p><p>
			To enable the menu widget, the root widget may initialize it. Then the
			menu can be accessed by view data. A simplified example for JSP (without
			style information) is below:

</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">widgetContext</span><span class="syntax10"> id</span>=<span class="syntax3">"</span><span class="syntax3">menu</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
  <span class="syntax10">&lt;</span><span class="syntax10">c:</span><span class="syntax9">forEach</span><span class="syntax10"> items</span>=<span class="syntax3">"</span><span class="syntax3">${viewData.menu.subMenu}</span><span class="syntax3">"</span><span class="syntax10"> var</span>=<span class="syntax3">"</span><span class="syntax3">item</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
    <span class="syntax10">&lt;</span><span class="syntax10">c:</span><span class="syntax9">if</span><span class="syntax10"> test</span>=<span class="syntax3">"</span><span class="syntax3">${item.value.selected}</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
      <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">eventLinkButton</span><span class="syntax10"> eventId</span>=<span class="syntax3">"</span><span class="syntax3">menuSelect</span><span class="syntax3">"</span><span class="syntax10"> eventParam</span>=<span class="syntax3">"</span><span class="syntax3">${item.value.label}</span><span class="syntax3">"</span><span class="syntax10"> labelId</span>=<span class="syntax3">"</span><span class="syntax3">${item.value.label}</span><span class="syntax3">"</span><span class="syntax10"> styleClass</span>=<span class="syntax3">"</span><span class="syntax3">active</span><span class="syntax3">"</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
    <span class="syntax10">&lt;</span><span class="syntax10">/c:</span><span class="syntax9">if</span><span class="syntax10">&gt;</span>

    <span class="syntax10">&lt;</span><span class="syntax10">c:</span><span class="syntax9">if</span><span class="syntax10"> test</span>=<span class="syntax3">"</span><span class="syntax3">${not item.value.selected}</span><span class="syntax3">"</span><span class="syntax10">&gt;</span>
      <span class="syntax10">&lt;</span><span class="syntax10">ui:</span><span class="syntax9">eventLinkButton</span><span class="syntax10"> eventId</span>=<span class="syntax3">"</span><span class="syntax3">menuSelect</span><span class="syntax3">"</span><span class="syntax10"> eventParam</span>=<span class="syntax3">"</span><span class="syntax3">${item.value.label}</span><span class="syntax3">"</span><span class="syntax10"> labelId</span>=<span class="syntax3">"</span><span class="syntax3">${item.value.label}</span><span class="syntax3">"</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
    <span class="syntax10">&lt;</span><span class="syntax10">/c:</span><span class="syntax9">if</span><span class="syntax10">&gt;</span>
  <span class="syntax10">&lt;</span><span class="syntax10">/c:</span><span class="syntax9">forEach</span><span class="syntax10">&gt;</span>
<span class="syntax10">&lt;</span><span class="syntax10">/ui:</span><span class="syntax9">widgetContext</span><span class="syntax10">&gt;</span>
</span></pre></pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ConfirmationContext"></a>2.8.7.&nbsp;ConfirmationContext</h3></div></div></div><p>
      Aranea standard component chain enriches <code class="literal">Environment</code>
      with a context called <code class="literal">ConfirmationContext</code>. This can be
      used for executing some code conditionally, depending on user actions.
      Context interface is simple and consists of following methods:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> ConfirmationContext <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>

  <span class="syntax8">void</span> <span class="syntax9">confirm</span>(Closure onConfirmClosure, String message);

  String <span class="syntax9">getConfirmationMessage</span>();

<span class="syntax11">}</span>
</span></pre></pre><p>

			There the <code class="literal">org.apache.commons.collections.Closure</code> is a
			simple interface to encapsulate business logic:
			
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax6">public</span> <span class="syntax8">interface</span> Closure <span class="syntax11">{</span>

  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">execute</span>(java.lang.Object input);

<span class="syntax11">}</span>
</span></pre></pre><p>
			The <code class="literal">input</code> param is <code class="literal">null</code> for transitions
			handlers.
      </p><p>
			When confirmation is registered (with the <code class="literal">confirm(...)</code>
			method), rendering mechanism will present end-user with the browser
			standard message box (on page load) and ask for confirmation of requested action.
			Depending on users choice, action encapsulated in the
			<code class="literal">onConfirmClosure</code> param either will get executed or not.
			</p><p>
			Combined with <code class="literal">FlowContext.TransitionHandler</code>, confirmation
			could be asked whenever the user performs navigation that would make active
			flow unreachable and flow contains data that has not yet been saved.

</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax9">getFlowCtx</span>().<span class="syntax9">setTransitionHandler</span>(
  <span class="syntax6">new</span> <span class="syntax9">CancelConfirmingTransitionHandler</span>(
      <span class="syntax6">new</span> <span class="syntax9">ShouldConfirmOnUnsavedData</span>(),
      <span class="syntax3">"Some data not saved yet. Continue anyway?"</span>));

</span></pre></pre><p>

			Here <code class="literal">CancelConfirmingTransitionHandler</code> (provided by Aranea)
			registers the confirmation whenever <code class="literal">FlowContext.cancel()</code> is
			called from active flow and <code class="literal">org.apache.commons.collections.Predicate</code>
			(that is used to check the custom condition before executing the event) 
			<code class="literal">ShouldConfirmOnUnsavedData</code> (not provided by Aranea) evaluates
			to <code class="literal">true</code>. Only after the user confirms the navigation, the event
			will allow flow transition to be actually be performed.
			</p><p>
			<code class="literal">ConfirmationContext</code> and <code class="literal">TransitionHandlers</code>
			together are a reliable and convenient way of preventing end-users shooting
			themselves in the foot.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ManagedServiceContext"></a>2.8.8.&nbsp;ManagedServiceContext, ThreadContext, and TopServiceContext</h3></div></div></div><p>
      This section describes the contexts that are at the core of request handling.
      </p><p>
      <code class="literal">org.araneaframework.framework.ManagedServiceContext</code> represents
      a context that handles the requests of different threads (windows) in one session.
      The basic idea is that it routes requests to the right services. Here's an overview
      of the interface:
</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax7">package</span> org.araneaframework.framework;

<span class="syntax6">public</span> <span class="syntax8">interface</span> ManagedServiceContext <span class="syntax6">extends</span> Serializable <span class="syntax11">{</span>

  <span class="syntax6">public</span> Object <span class="syntax9">getCurrentId</span>();

  <span class="syntax6">public</span> Service <span class="syntax9">addService</span>(Object id, Service service);

  <span class="syntax6">public</span> Service <span class="syntax9">addService</span>(Object id, Service service, Long timeToLive);

  <span class="syntax6">public</span> Service <span class="syntax9">getService</span>(Object id);

  <span class="syntax6">public</span> <span class="syntax8">void</span> <span class="syntax9">close</span>(Object id);

<span class="syntax11">}</span>
</span></pre></pre><p>
			</p><p>
			<code class="literal">org.araneaframework.framework.ThreadContext</code> represents
			a context that makes popups possible. Without it the user would have the
			same session in both windows, because Aranea application has a state.
			<code class="literal">ThreadContext</code>, however, provides means to create a
			new (distinct) thread in the session. A proof that a
			<code class="literal">ThreadContext</code> is running in a web application is
			the fact that you can find something like this in the source code of a page:
			</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax10">&lt;</span><span class="syntax10">input name</span><span class="syntax11">=</span><span class="syntax3">"araThreadServiceId"</span><span class="syntax10"> type</span><span class="syntax11">=</span><span class="syntax3">"hidden"</span><span class="syntax10"> value</span><span class="syntax11">=</span><span class="syntax3">"mainThread"</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
</span></pre></pre><p>
			It means that the next request (submit) made will be bound to the <code class="literal">mainThread</code>.
			</p><p>
			<code class="literal">org.araneaframework.framework.TopServiceContext</code> further
			specifies the <code class="literal">ManagedServiceContext</code> by being the top-most
			(and thus accessible by all users), though it works like <code class="literal">ThreadContext</code>.
			The difference, however, lies in the fact that <code class="literal">TopServiceContext</code>
			is not session based. Therefore, it would handle threads when, for example, the user
			has not logged in. And one may see it in their Aranea application page as following:
			</p><pre class="programlisting"><pre><span class="syntax0"><span class="syntax10">&lt;</span><span class="syntax10">input name</span><span class="syntax11">=</span><span class="syntax3">"araTopServiceId"</span><span class="syntax10"> type</span><span class="syntax11">=</span><span class="syntax3">"hidden"</span><span class="syntax10"> value</span><span class="syntax11">=</span><span class="syntax3">"application"</span><span class="syntax10">/</span><span class="syntax10">&gt;</span>
</span></pre></pre><p>
			</p><p>
			<code class="literal">ThreadContext</code> and <code class="literal">TopServiceContext</code> do not
			introduce new methods compared to <code class="literal">ManagedServiceContext</code>.
			</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="intro.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="framework.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Introduction&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Framework and Configuration</td></tr></table></div></body></html>